#' Read the ECG file generated by WFDB2MAT.
#'
#' This function reads the tuple data.mat and data.hea that contains the signal and the header with information about
#' the signal.
#'
#' @param filename character vector. Path to the file data. Without the extension .mat. Must exist both .mat and .hea
#'  in the path
#' @param plot a logical value. If the imported file will be plotted. Default is FALSE.
#'
#' @details
#'
#' # Acknowledgment
#'
#' This is a R port from the Matlab's code written by Ikaro Silva, 2014, Version 1.1
#'
#' # Known limitations
#'
#' This function currently does support several of the features described in the WFDB record format (such as
#' multiresolution signals):
#'          http://www.physionet.org/physiotools/wag/header-5.htm
#'  If you are not sure that the record (or database format) you are reading is supported, you can do an integrity
#'  check by comparing the output with RDSAMP.
#'
#'  if(sum(abs(signal-signal2)) !=0);
#'    stop('Record not compatible with RDMAT');
#'  end
#'
#' These tools are available at: https://archive.physionet.org/physiotools/binaries/
#'
#' @return
#' Returns a `list` with the signals and the attributes of the file:
#'
#' - time: timestamp of each observation, in seconds
#' - "signal": the value of the signal on each timestamp. The name of this object is the name of the signal, for
#' example 'II', 'PLETH'.
#'   - signal attributes "info":
#'     - baseline: numeric value
#'     - grain: numeric value
#'     - unit: char
#' - dataset attributes "info":
#'   - alarm: type of alarm, for ex: "Asystole".
#'   - true: if the alarm is true or not, for ex: "False".
#'   - filename: the name of the original file, without the extension.
#'   - frequency: the frequency of the observations, in Hz.
#' @export
#'
#' @examples
#' \dontrun{
#' signal <- read_ecg("data/a103l")
#' }
#'
read_ecg <- function(filename, plot = FALSE) {
  checkmate::assert_string(filename, 3)
  checkmate::qassert(plot, "B")
  #
  # Set default parameter values
  def_gain <- 200 # Default value for missing gains
  wfdb_nan <- -32768 # This should be the case for all WFDB signal format types currently supported by RDMAT

  if (tools::file_ext(filename) == "hea") {
    filename <- tools::file_path_sans_ext(filename)
  }

  header <- paste0(filename, ".hea")
  content <- paste0(filename, ".mat.bz2")
  basename <- basename(filename)

  if (!file.exists(header) | !file.exists(content)) {
    stop("File ", filename, "does not exist.")
  }

  # Following the documentation described in :
  # http://www.physionet.org/physiotools/wag/header-5.htm
  # to parse the header file

  hea <- file(header, "r")
  hea_content <- readLines(hea)
  close(hea)

  # Skip any comment lines
  for (i in seq_along(hea_content)) {
    if (substr(hea_content[i], 1, 1) == "#") {
      next
    } else {
      break
    }
  }

  if (i == length(hea_content)) {
    stop("The file only contains comments.")
  }

  nlines <- length(hea_content)

  hea_content <- strsplit(hea_content[i:length(hea_content)], " ")

  n_signals <- as.numeric(hea_content[[1]][2]) # Number of signals present
  freq_signal <- as.numeric(hea_content[[1]][3]) # Frequency of the signal

  # Process Signal Specification lines. Assumes no comments between lines.
  siginfo <- list()

  for (i in (seq_len(n_signals) + 1)) {
    gain <- hea_content[[i]][3]
    # Get Signal Units if present
    gain <- unlist(strsplit(gain, "/"))
    unit <- NULL

    if (length(gain) == 2) {
      unit <- gain[2]
      gain <- as.numeric(gain[1])
    } else {
      gain <- as.numeric(gain)

      # if zero set as default
      if (gain == 0) {
        gain <- def_gain
      }
    }

    siginfo[[i - 1]] <- list()

    siginfo[[i - 1]]["gain"] <- gain
    siginfo[[i - 1]]["unit"] <- unit
    siginfo[[i - 1]]["baseline"] <- as.numeric(hea_content[[i]][5])
    siginfo[[i - 1]]["description"] <- hea_content[[i]][9]
  }

  if (nlines != n_signals) {
    alarm <- hea_content[[nlines - 1]][1]
    alarm <- ifelse(substr(alarm, 1, 1) == "#", substring(alarm, 2), alarm)
    true_false <- hea_content[[nlines]][1]
    true_false <- ifelse(substr(true_false, 1, 1) == "#", substring(true_false, 2), true_false)
  }

  mat_file <- gzfile(content, "rb")
  mat_content <- R.matlab::readMat(mat_file)
  close(mat_file)

  signal <- list()
  # Convert from digital units to physical units.
  # Mapping should be similar to that of rdsamp.c:
  # http://www.physionet.org/physiotools/wfdb/app/rdsamp.c
  for (i in seq_len(n_signals)) {
    mat_content$val[i, is.na(mat_content$val[i, ])] <- wfdb_nan
    label <- siginfo[[i]]$description
    signal[[label]] <- (mat_content$val[i, ] - siginfo[[i]]$baseline) / siginfo[[i]]$gain
    attr(signal[[label]], "info") <- list(baseline = siginfo[[i]]$baseline, gain = siginfo[[i]]$gain, unit = siginfo[[i]]$unit)
  }

  length_signal <- length(signal[[1]])
  # Generate time vector
  tm <- seq(0, (length_signal - 1) / freq_signal, length.out = length_signal)

  output <- list()
  output[[basename]] <- c(list(time = tm), signal)

  attr(output[[basename]], "info") <- list(alarm = alarm, true = as.logical(true_false), filename = basename, frequency = freq_signal)

  if (plot) {
    plot_ecg(output[[basename]])

    # plot.ts(output, nc = 1, main = paste("Output from", basename(filename)))
    # mtext(paste0("tags: ", attr(output, "result")$alarm, ", ", attr(output, "result")$true, " Alarm"), 3, line = 1, adj = 0)
  }

  return(output)
}
