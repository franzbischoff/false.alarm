rdmat <- function(filename) {
  #
  # [tm,signal,Fs,siginfo]=rdmat(recordName)
  #
  # Import a signal in physical units from a *[['mat']] file generated by WFDB2MAT.
  # Required Parameters:
  #
  # recorName
  #       String specifying the name of the *[['mat']] file.
  #
  # Outputs are:
  #
  # tm
  #       A Nx1 array of doubles specifying the time in seconds.
  # signal
  #       A NxM matrix of doubles contain the signals in physical units.
  # Fs
  #       A 1x1 integer specifying the sampling frequency in Hz for the entire record.
  # siginfo
  #       A LxN cell array specifying the signal siginfo. Currently it is a
  #       structure with the following fields:
  #
  #        siginfo[['Units']]
  #        siginfo[['Baseline']]
  #        siginfo[['Gain']]
  #        siginfo[['Description']]
  #
  # NOTE:
  #       You can use the WFDB2MAT command in order to convert the record data into a *.mat file,
  #       which can then be loaded into MATLAB/Octave's workspace using the LOAD command.
  #       This sequence of procedures is quicker (by several orders of magnitude) than calling RDSAMP.
  #       The LOAD command will load the signal data in raw units, use RDMAT to load the signal in physical units.
  #
  # KNOWN LIMITATIONS:
  #       This function currently does support several of the features described
  #       in the WFDB record format (such as multiresolution signals) :
  #          http://www[['physionet']][['org']]/physiotools/wag/header-5[['htm']]
  #       If you are not sure that the record (or database format) you are reading is
  #       supported, you can do an integrity check by comparing the output with RDSAMP:
  #
  #       [tm,signal,Fs,siginfo]=rdmat('200m');
  #       [tm2,signal2]=rdsamp('200m');
  #       if(sum(abs(signal-signal2)) !=0);
  #          stop('Record not compatible with RDMAT');
  #       end
  #
  #
  # Written by Ikaro Silva, 2014
  # Last Modified: November 17, 2014
  # Version 1.1
  #
  # Since 0.9.7
  #
  # #Example:
  # wfdb2mat('mitdb/200')
  # tic;[tm,signal,Fs,siginfo]=rdmat('200m');toc
  # tic;[tm2,signal2]=rdsamp('200m');toc
  # sum(abs(signal-signal2))
  #
  #
  # See also RDSAMP, WFDB2MAT
  # endOfHelp

  # Set default pararameter values
  defGain <- 200 # Default value for missing gains
  wfdbNaN <- -32768 # This should be the case for all WFDB signal format types currently supported by RDMAT

  header <- paste0(filename, ".hea")
  content <- paste0(filename, ".mat")

  if (!file.exists(header) | !file.exists(content)) {
    stop("File ", filename, "does not exist.")
  }

  # Following the documentation described in :
  # http://www.physionet.org/physiotools/wag/header-5.htm
  # to parse the header file

  hea <- file(header, "r")
  hea_content <- readLines(hea)
  close(hea)

  # Skip any comment lines
  for (i in seq_along(hea_content)) {
    if (substr(hea_content[i], 1, 1) == "#") {
      next
    } else {
      break
    }
  }

  if (i == length(hea_content)) {
    stop("The file only contains comments.")
  }

  hea_content <- strsplit(hea_content[i:length(hea_content)], " ")

  M <- as.numeric(hea_content[[1]][2]) # Number of signals present
  Fs <- as.numeric(hea_content[[1]][3]) # Frequency of the signal


  # Process Signal Specification lines. Assumes no comments between lines.
  siginfo <- list()

  for (i in (seq_len(M) + 1)) {
    gain <- hea_content[[i]][3]
    # Get Signal Units if present
    gain <- unlist(strsplit(gain, "/"))
    unit <- NULL

    if (length(gain) == 2) {
      unit <- gain[2]
      gain <- as.numeric(gain[1])
    } else {
      gain <- as.numeric(gain)

      # if zero set as default
      if (gain == 0) {
        gain <- defGain
      }
    }

    siginfo[[i - 1]] <- list()

    siginfo[[i - 1]]["gain"] <- gain
    siginfo[[i - 1]]["unit"] <- unit

    # Get Signal Baseline if present TODO: review this, may be a value between ()
    siginfo[[i - 1]]["baseline"] <- as.numeric(hea_content[[i]][5])
    siginfo[[i - 1]]["description"] <- hea_content[[i]][9]
  }

  mat_content <- R.matlab::readMat(content)

  signal <- list()
  # Convert from digital units to physical units.
  # Mapping should be similar to that of rdsamp.c:
  # http://www.physionet.org/physiotools/wfdb/app/rdsamp.c
  for (i in seq_len(M)) {
    mat_content$val[i, is.na(mat_content$val[i, ])] <- wfdbNaN
    signal[[i]] <- (mat_content$val[i, ] - siginfo[[i]]$baseline) / siginfo[[i]]$gain
  }

  N <- length(signal[[1]])
  # Generate time vector
  tm <- seq(0, (N - 1) / Fs, length.out = N)

  return(list(tm = tm, signals = signal, Fs = Fs, siginfo = siginfo))
}
