#' Read the ECG file generated by WFDB2MAT.
#'
#' This function reads the tuple data.mat and data.hea that contains the signal and the header with information about
#' the signal.
#'
#' @param filename character vector. Path to the file data. Without the extension .mat. Must exist both .mat and .hea
#'  in the path
#' @param plot a logical value. If the imported file will be plotted. Default is FALSE.
#'
#' @details
#'
#' # Acknowledgment
#'
#' This is a R port from the Matlab's code written by Ikaro Silva, 2014, Version 1.1
#'
#' # Known limitations
#'
#' This function currently does support several of the features described in the WFDB record format (such as
#' multiresolution signals):
#'          http://www.physionet.org/physiotools/wag/header-5.htm
#'  If you are not sure that the record (or database format) you are reading is supported, you can do an integrity
#'  check by comparing the output with RDSAMP.
#'
#'  if(sum(abs(signal-signal2)) !=0);
#'    stop('Record not compatible with RDMAT');
#'  end
#'
#' These tools are available at: https://archive.physionet.org/physiotools/binaries/
#'
#' @return
#' Returns a `list` with the signals and the attributes of the file:
#'
#' - time: timestamp of each observation, in seconds
#' - "signal": the value of the signal on each timestamp. The name of this object is the name of the signal, for
#' example 'II', 'PLETH'.
#'   - signal attributes "info":
#'     - baseline: numeric value
#'     - grain: numeric value
#'     - unit: char
#' - dataset attributes "info":
#'   - alarm: type of alarm, for ex: "Asystole".
#'   - true: if the alarm is true or not, for ex: "False".
#'   - filename: the name of the original file, without the extension.
#'   - frequency: the frequency of the observations, in Hz.
#'
#' @examples
#' \dontrun{
#' signal <- read_ecg("data/a103l")
#' }
#'
read_ecg <- function(filename, plot = FALSE, subset = FALSE,
                     types = c("all", "asystole", "bradycardia", "tachycardia", "vfib", "vtachy"),
                     true_alarm = NULL) {
  checkmate::assert_string(filename, 3)
  checkmate::qassert(plot, "B")
  checkmate::qassert(true_alarm, c("0", "B"))
  types <- match.arg(types, several.ok = TRUE)

  if (!("all" %in% types)) {
    filtered <- NULL

    for (type in types) {
      res <- switch(type,
        asystole = grep("a\\d*.\\.hea", filename, value = TRUE),
        bradycardia = grep("b\\d*.\\.hea", filename, value = TRUE),
        tachycardia = grep("t\\d*.\\.hea", filename, value = TRUE),
        vfib = grep("f\\d*.\\.hea", filename, value = TRUE),
        vtachy = grep("c\\d*.\\.hea", filename, value = TRUE)
      )

      filtered <- c(filtered, res)
    }

    if (rlang::is_empty(filtered)) {
      message("File skipped: ", filename)
      return(NULL)
    }
  }

  # Set default parameter values
  def_gain <- 200 # Default value for missing gains
  wfdb_nan <- -32768 # This should be the case for all WFDB signal format types currently supported by RDMAT

  if (tools::file_ext(filename) == "hea") {
    filename <- tools::file_path_sans_ext(filename)
  }

  header <- paste0(filename, ".hea")
  content <- paste0(filename, ".mat.bz2")
  basename <- basename(filename)

  if (!file.exists(header) | !file.exists(content)) {
    stop("File ", filename, "does not exist.")
  }

  # Following the documentation described in :
  # http://www.physionet.org/physiotools/wag/header-5.htm
  # to parse the header file

  hea <- file(header, "r")
  hea_content <- readLines(hea)
  close(hea)

  # Skip any comment lines
  for (i in seq_along(hea_content)) {
    if (substr(hea_content[i], 1, 1) == "#") {
      next
    } else {
      break
    }
  }

  if (i == length(hea_content)) {
    stop("The file only contains comments.")
  }

  nlines <- length(hea_content)

  hea_content <- strsplit(hea_content[i:length(hea_content)], " ")

  n_signals <- as.numeric(hea_content[[1]][2]) # Number of signals present
  freq_signal <- as.numeric(hea_content[[1]][3]) # Frequency of the signal

  # Process Signal Specification lines. Assumes no comments between lines.
  siginfo <- list()

  for (i in (seq_len(n_signals) + 1)) {
    gain <- hea_content[[i]][3]
    # Get Signal Units if present
    gain <- unlist(strsplit(gain, "/"))
    unit <- NULL

    if (length(gain) == 2) {
      unit <- gain[2]
      gain <- as.numeric(gain[1])
    } else {
      gain <- as.numeric(gain)

      # if zero set as default
      if (gain == 0) {
        gain <- def_gain
      }
    }

    siginfo[[i - 1]] <- list()

    siginfo[[i - 1]]["gain"] <- gain
    siginfo[[i - 1]]["unit"] <- unit
    siginfo[[i - 1]]["baseline"] <- as.numeric(hea_content[[i]][5])
    siginfo[[i - 1]]["description"] <- hea_content[[i]][9]
  }

  if (nlines != n_signals) {
    alarm <- hea_content[[nlines - 1]][1]
    alarm <- ifelse(substr(alarm, 1, 1) == "#", substring(alarm, 2), alarm)
    true_false <- hea_content[[nlines]][1]
    true_false <- ifelse(substr(true_false, 1, 1) == "#", substring(true_false, 2), true_false)
  }

  if (!is.null(true_alarm)) {
    if (true_alarm != as.logical(true_false)) {
      message("File skipped: ", filename)
      return(NULL)
    }
  }

  mat_file <- gzfile(content, "rb")
  mat_content <- R.matlab::readMat(mat_file)
  close(mat_file)

  signal <- list()
  subset_minmax <- FALSE
  if (!isFALSE(subset)) {
    subset_minmax <- c(min(subset), max(subset))
  }
  # Convert from digital units to physical units.
  # Mapping should be similar to that of rdsamp.c:
  # http://www.physionet.org/physiotools/wfdb/app/rdsamp.c
  for (i in seq_len(n_signals)) {
    mat_content$val[i, is.na(mat_content$val[i, ])] <- wfdb_nan
    label <- siginfo[[i]]$description
    signal[[label]] <- (mat_content$val[i, ] - siginfo[[i]]$baseline) / siginfo[[i]]$gain

    if (!isFALSE(subset)) {
      signal[[label]] <- signal[[label]][subset]
    }

    attr(signal[[label]], "info") <- list(label = label, baseline = siginfo[[i]]$baseline, gain = siginfo[[i]]$gain, unit = siginfo[[i]]$unit, subset = subset_minmax)
  }

  length_signal <- length(signal[[1]])
  # Generate time vector
  tm <- seq(0, (length_signal - 1) / freq_signal, length.out = length_signal)

  output <- list()
  output[[basename]] <- c(list(time = tm), signal)

  attr(output[[basename]], "info") <- list(alarm = alarm, true = as.logical(true_false), filename = basename, frequency = freq_signal, id = "base", ids = "base")

  if (plot) {
    plot_ecg(output[[basename]])

    # plot.ts(output, nc = 1, main = paste("Output from", basename(filename)))
    # mtext(paste0("tags: ", attr(output, "result")$alarm, ", ", attr(output, "result")$true, " Alarm"), 3, line = 1, adj = 0)
  }

  return(output)
}

#' Read the ECG file generated by WFDB2MAT.
#'
#' This function reads the tuple data.mat and data.hea that contains the signal and the header with information about
#' the signal.
#'
#' @param filename character vector. Path to the file data. Without the extension .mat. Must exist both .mat and .hea
#'  in the path
#' @param plot a logical value. If the imported file will be plotted. Default is FALSE.
#'
#' @details
#'
#' # Acknowledgment
#'
#' This is a R port from the Matlab's code written by Ikaro Silva, 2014, Version 1.1
#'
#' # Known limitations
#'
#' This function currently does support several of the features described in the WFDB record format (such as
#' multiresolution signals):
#'          http://www.physionet.org/physiotools/wag/header-5.htm
#'  If you are not sure that the record (or database format) you are reading is supported, you can do an integrity
#'  check by comparing the output with RDSAMP.
#'
#'  if(sum(abs(signal-signal2)) !=0);
#'    stop('Record not compatible with RDMAT');
#'  end
#'
#' These tools are available at: https://archive.physionet.org/physiotools/binaries/
#'
#' @return
#' Returns a `list` with the signals and the attributes of the file:
#'
#' - time: timestamp of each observation, in seconds
#' - "signal": the value of the signal on each timestamp. The name of this object is the name of the signal, for
#' example 'II', 'PLETH'.
#'   - signal attributes "info":
#'     - baseline: numeric value
#'     - grain: numeric value
#'     - unit: char
#' - dataset attributes "info":
#'   - alarm: type of alarm, for ex: "Asystole".
#'   - true: if the alarm is true or not, for ex: "False".
#'   - filename: the name of the original file, without the extension.
#'   - frequency: the frequency of the observations, in Hz.
#'
#' @examples
#' \dontrun{
#' signal <- read_ecg("data/a103l")
#' }
#'
read_ecg_csv <- function(filename, plot = FALSE, subset = FALSE,
                         types = c("all", "asystole", "bradycardia", "tachycardia", "vfib", "vtachy"),
                         true_alarm = NULL) {
  checkmate::assert_string(filename, 3)
  checkmate::qassert(plot, "B")
  checkmate::qassert(true_alarm, c("0", "B"))
  types <- match.arg(types, several.ok = TRUE)

  if (!("all" %in% types)) {
    filtered <- NULL

    for (type in types) {
      res <- switch(type,
        asystole = grep("a\\d*.\\.hea", filename, value = TRUE),
        bradycardia = grep("b\\d*.\\.hea", filename, value = TRUE),
        tachycardia = grep("t\\d*.\\.hea", filename, value = TRUE),
        vfib = grep("f\\d*.\\.hea", filename, value = TRUE),
        vtachy = grep("c\\d*.\\.hea", filename, value = TRUE)
      )

      filtered <- c(filtered, res)
    }

    if (rlang::is_empty(filtered)) {
      message("File skipped (not in type): ", filename)
      return(NULL)
    }
  }

  # Set default parameter values
  def_gain <- 200 # Default value for missing gains
  wfdb_nan <- -32768 # This should be the case for all WFDB signal format types currently supported by RDMAT

  if (tools::file_ext(filename) == "hea") {
    filename <- tools::file_path_sans_ext(filename)
  }

  header <- paste0(filename, ".hea")
  content <- paste0(filename, ".csv.bz2")
  basename <- basename(filename)

  if (!file.exists(header) | !file.exists(content)) {
    stop("File ", filename, "does not exist.")
  }

  # Following the documentation described in :
  # http://www.physionet.org/physiotools/wag/header-5.htm
  # to parse the header file

  hea <- file(header, "r")
  hea_content <- readLines(hea)
  close(hea)

  # Skip any comment lines
  for (i in seq_along(hea_content)) {
    if (substr(hea_content[i], 1, 1) == "#") {
      next
    } else {
      break
    }
  }

  if (i == length(hea_content)) {
    stop("The file only contains comments.")
  }

  nlines <- length(hea_content)

  hea_content <- strsplit(hea_content[i:length(hea_content)], " ")

  n_signals <- as.numeric(hea_content[[1]][2]) # Number of signals present
  freq_signal <- as.numeric(hea_content[[1]][3]) # Frequency of the signal

  # Process Signal Specification lines. Assumes no comments between lines.
  siginfo <- list()

  for (i in (seq_len(n_signals) + 1)) {
    gain <- hea_content[[i]][3]
    # Get Signal Units if present
    gain <- unlist(strsplit(gain, "/"))
    unit <- NULL

    if (length(gain) == 2) {
      unit <- gain[2]
      gain <- as.numeric(gain[1])
    } else {
      gain <- as.numeric(gain)

      # if zero set as default
      if (gain == 0) {
        gain <- def_gain
      }
    }

    siginfo[[i - 1]] <- list()

    siginfo[[i - 1]]["gain"] <- gain
    siginfo[[i - 1]]["unit"] <- unit
    siginfo[[i - 1]]["baseline"] <- as.numeric(hea_content[[i]][5])
    siginfo[[i - 1]]["description"] <- hea_content[[i]][9]
  }

  if (nlines != n_signals) {
    alarm <- hea_content[[nlines - 1]][1]
    alarm <- ifelse(substr(alarm, 1, 1) == "#", substring(alarm, 2), alarm)
    true_false <- hea_content[[nlines]][1]
    true_false <- ifelse(substr(true_false, 1, 1) == "#", substring(true_false, 2), true_false)
  }

  if (!is.null(true_alarm)) {
    if (true_alarm != as.logical(true_false)) {
      message("File skipped (alarm is ", !true_alarm, "): ", filename)
      return(NULL)
    }
  }

  csv_content <- readr::read_csv(content, show_col_types = FALSE, col_types = "nnnnnnn")

  # mat_file <- gzfile(content, "rb")
  # mat_content <- R.matlab::readMat(mat_file)
  # close(mat_file)

  signal <- list()
  subset_minmax <- FALSE
  if (!isFALSE(subset)) {
    subset_minmax <- c(min(subset), max(subset))
  }
  # Convert from digital units to physical units.
  # Mapping should be similar to that of rdsamp.c:
  # http://www.physionet.org/physiotools/wfdb/app/rdsamp.c
  for (i in seq_len(n_signals)) {
    csv_content[is.na(csv_content[[i]]), i] <- wfdb_nan
    label <- siginfo[[i]]$description
    signal[[label]] <- (csv_content[[i]] - siginfo[[i]]$baseline) / siginfo[[i]]$gain

    if (!isFALSE(subset)) {
      signal[[label]] <- signal[[label]][subset]
    }

    attr(signal[[label]], "info") <- list(label = label, baseline = siginfo[[i]]$baseline, gain = siginfo[[i]]$gain, unit = siginfo[[i]]$unit, subset = subset_minmax)
  }

  length_signal <- length(signal[[1]])
  # Generate time vector
  tm <- seq(0, (length_signal - 1) / freq_signal, length.out = length_signal)

  output <- list()
  output[[basename]] <- c(list(time = tm), signal)

  attr(output[[basename]], "info") <- list(alarm = alarm, true = as.logical(true_false), filename = basename, frequency = freq_signal, id = "base", ids = "base")

  if (plot) {
    plot_ecg(output[[basename]])

    # plot.ts(output, nc = 1, main = paste("Output from", basename(filename)))
    # mtext(paste0("tags: ", attr(output, "result")$alarm, ", ", attr(output, "result")$true, " Alarm"), 3, line = 1, adj = 0)
  }

  return(output)
}


read_and_prepare_ecgs <- function(file_paths, subset = FALSE, true_alarm = NULL, limit_per_type = NULL) {
  result <- list()
  types <- list()

  for (file in file_paths) {
    filename <- tools::file_path_sans_ext(basename(file))

    it <- read_ecg_csv(file,
      subset = subset,
      true_alarm = true_alarm
    )

    if (!is.null(it)) {
      if (is.numeric(limit_per_type)) {
        type <- substr(filename, 1, 1)
        if (is.null(types[[type]])) {
          types[[type]] <- 1
        } else {
          types[[type]] <- types[[type]] + 1
        }
        if (types[[type]] > limit_per_type) {
          next
        }
      }

      result[filename] <- it
    }
  }

  return(result)
}

reshape_dataset_by_truefalse <- function(dataset, include) {
  # divide in TRUE and FALSE
  df_true <- purrr::keep(dataset, ~ attr(.x, "info")$true)
  df_false <- purrr::keep(dataset, ~ !attr(.x, "info")$true)

  # filter by presence of include
  df_true <- purrr::keep(df_true, ~ all(include %in% names(.x)))
  df_false <- purrr::keep(df_false, ~ all(include %in% names(.x)))

  # # convert from list by file to list by time series
  df_true <- purrr::transpose(df_true)
  df_false <- purrr::transpose(df_false)

  # keep only the series we will include:
  df_true <- df_true[include]
  df_false <- df_false[include]


  # convert trues and falses into a tibble for later use on rsample
  df_true <- purrr::map(df_true, function(x) {
    files <- names(x)
    tibble::tibble(
      file = files, val = runif(1), values = x, alarm = factor("true", c("true", "false"))
    )
  })

  df_false <- purrr::map(df_false, function(x) {
    files <- names(x)
    tibble::tibble(
      file = files, val = runif(1), values = x, alarm = factor("false", c("true", "false"))
    )
  })

  data <- dplyr::bind_rows(df_true, df_false)

  return(data)
}
