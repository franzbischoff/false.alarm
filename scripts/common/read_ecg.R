#' Read the ECG file generated by WFDB2MAT.
#'
#' This function reads the tuple data.mat and data.hea that contains the signal and the header with information about
#' the signal.
#'
#' @param filename character vector. Path to the file data. Without the extension .mat. Must exist both .mat and .hea
#'  in the path
#' @param plot a logical value. If the imported file will be plotted. Default is FALSE.
#' @param subset integer sequence. Select only this subset for the dataset. Default is NULL
#' @param classes character vector. Defines which classes will be imported. Default is "all"
#' @param true_alarm logical value or NULL. Select only the TRUE or FALSE alarms. Default is NULL, means all alarms.
#'
#' @details
#'
#' # Acknowledgment
#'
#' This is a R port from the Matlab's code written by Ikaro Silva, 2014, Version 1.1
#'
#' # Known limitations
#'
#' This function currently does support several of the features described in the WFDB record format (such as
#' multiresolution signals):
#'          http://www.physionet.org/physiotools/wag/header-5.htm
#'  If you are not sure that the record (or database format) you are reading is supported, you can do an integrity
#'  check by comparing the output with RDSAMP.
#'
#'  if(sum(abs(signal-signal2)) !=0);
#'    stop('Record not compatible with RDMAT');
#'  end
#'
#' These tools are available at: https://archive.physionet.org/physiotools/binaries/
#'
#' @return
#' Returns a `list` with the signals and the attributes of the file:
#'
#' - time: timestamp of each observation, in seconds
#' - "signal": the value of the signal on each timestamp. The name of this object is the name of the signal, for
#' example 'II', 'PLETH'.
#'   - signal attributes "info":
#'     - baseline: numeric value
#'     - grain: numeric value
#'     - unit: char
#' - dataset attributes "info":
#'   - alarm: class of alarm, for ex: "Asystole".
#'   - true: if the alarm is true or not, for ex: "False".
#'   - filename: the name of the original file, without the extension.
#'   - frequency: the frequency of the observations, in Hz.
#'
#' @examples
#' \dontrun{
#' signal <- read_ecg("data/a103l")
#' }
#'
read_ecg <- function(filename, plot = FALSE, subset = NULL,
                     classes = c("all", "asystole", "bradycardia", "tachycardia", "fibv", "vtachy"),
                     true_alarm = NULL) {
  checkmate::assert_string(filename, 3)
  checkmate::qassert(plot, "B")
  checkmate::qassert(true_alarm, c("0", "B"))
  classes <- match.arg(classes, several.ok = TRUE)

  if (!("all" %in% classes)) {
    filtered <- NULL

    for (class in classes) {
      res <- switch(class,
        asystole = grep("a\\d*.\\.hea", filename, value = TRUE),
        bradycardia = grep("b\\d*.\\.hea", filename, value = TRUE),
        tachycardia = grep("t\\d*.\\.hea", filename, value = TRUE),
        fibv = grep("f\\d*.\\.hea", filename, value = TRUE),
        vtachy = grep("v\\d*.\\.hea", filename, value = TRUE)
      )

      filtered <- c(filtered, res)
    }

    if (rlang::is_empty(filtered)) {
      message("File skipped: ", filename)
      return(NULL)
    }
  }

  # Set default parameter values
  def_gain <- 200 # Default value for missing gains
  wfdb_nan <- -32768 # This should be the case for all WFDB signal format types currently supported by RDMAT

  if (tools::file_ext(filename) == "hea") {
    filename <- tools::file_path_sans_ext(filename)
  }

  header <- paste0(filename, ".hea")
  content <- paste0(filename, ".mat.bz2")
  basename <- basename(filename)

  if (!file.exists(header) | !file.exists(content)) {
    stop("File ", filename, "does not exist.")
  }

  # Following the documentation described in :
  # http://www.physionet.org/physiotools/wag/header-5.htm
  # to parse the header file

  hea <- file(header, "r")
  hea_content <- readLines(hea)
  close(hea)

  # Skip any comment lines
  for (i in seq_along(hea_content)) {
    if (substr(hea_content[i], 1, 1) == "#") {
      next
    } else {
      break
    }
  }

  if (i == length(hea_content)) {
    stop("The file only contains comments.")
  }

  nlines <- length(hea_content)

  hea_content <- strsplit(hea_content[i:length(hea_content)], " ")

  n_signals <- as.numeric(hea_content[[1]][2]) # Number of signals present
  freq_signal <- as.numeric(hea_content[[1]][3]) # Frequency of the signal

  # Process Signal Specification lines. Assumes no comments between lines.
  siginfo <- list()

  for (i in (seq_len(n_signals) + 1)) {
    format <- hea_content[[i]][2]
    gain <- hea_content[[i]][3]
    # Get Signal Units if present
    gain <- unlist(strsplit(gain, "/"))
    unit <- NULL

    # gain_baseline?
    gain_baseline <- unlist(strsplit(gain[1], "\\("))
    if (length(gain_baseline) == 2) {
      gain_baseline <- unlist(strsplit(gain_baseline, "\\)"))
      gain[1] <- gain_baseline[1]
      gain_baseline <- as.numeric(gain_baseline[2])
    } else {
      gain_baseline <- NULL
    }

    if (length(gain) == 2) {
      unit <- gain[2]
      gain <- as.numeric(gain[1])
    } else {
      gain <- as.numeric(gain)

      # if zero set as default
      if (gain == 0) {
        gain <- def_gain
      }
    }

    siginfo[[i - 1]] <- list()

    siginfo[[i - 1]]["format"] <- format # (-32767 +32767) 16+24 == 16 sixteen-bit amplitudes + 24 byte offset
    siginfo[[i - 1]]["gain"] <- gain
    siginfo[[i - 1]]["unit"] <- unit
    siginfo[[i - 1]]["resolution"] <- as.numeric(hea_content[[i]][4]) # bits resolution of the analog-to-digital converter used to digitize the signal
    if (is.null(gain_baseline)) {
      siginfo[[i - 1]]["baseline"] <- as.numeric(hea_content[[i]][5])
    } else {
      siginfo[[i - 1]]["baseline"] <- gain_baseline
    }
    siginfo[[i - 1]]["first"] <- as.numeric(hea_content[[i]][6])
    siginfo[[i - 1]]["chksum"] <- as.numeric(hea_content[[i]][7])
    siginfo[[i - 1]]["blocksize"] <- as.numeric(hea_content[[i]][8])
    siginfo[[i - 1]]["description"] <- hea_content[[i]][9]
  }

  if (nlines != n_signals) {
    alarm <- hea_content[[nlines - 1]][1]
    alarm <- ifelse(substr(alarm, 1, 1) == "#", substring(alarm, 2), alarm)
    true_false <- hea_content[[nlines]][1]
    true_false <- ifelse(substr(true_false, 1, 1) == "#", substring(true_false, 2), true_false)
  }

  if (!is.null(true_alarm)) {
    if (true_alarm != as.logical(true_false)) {
      message("File skipped: ", filename)
      return(NULL)
    }
  }

  mat_file <- gzfile(content, "rb")
  mat_content <- R.matlab::readMat(mat_file)
  close(mat_file)

  signals <- list()
  subset_minmax <- FALSE
  if (!is.null(subset)) {
    subset_minmax <- c(min(subset), max(subset))
  }
  # Convert from digital units to physical units.
  # Mapping should be similar to that of rdsamp.c:
  # http://www.physionet.org/physiotools/wfdb/app/rdsamp.c
  for (i in seq_len(n_signals)) {
    checkmate::assert_true(csv_content[[i]][1] == siginfo[[i]]$first)
    chksum <- (sum(csv_content[[i]]) %% 2^16)
    if (chksum >= 2^15) {
      chksum <- chksum - 2^16
    }
    checkmate::assert_true(chksum == siginfo[[i]]$chksum)

    mat_content$val[i, is.na(mat_content$val[i, ])] <- wfdb_nan
    signal <- siginfo[[i]]$description
    signals[[signal]] <- (mat_content$val[i, ] - siginfo[[i]]$baseline) / siginfo[[i]]$gain

    if (!is.null(subset)) {
      signals[[signal]] <- signals[[signal]][subset]
    }

    attr(signals[[signal]], "info") <- list(signal = signal, baseline = siginfo[[i]]$baseline, gain = siginfo[[i]]$gain, unit = siginfo[[i]]$unit, subset = subset_minmax)
  }

  length_signal <- length(signals[[1]])
  # Generate time vector
  tm <- seq(0, (length_signal - 1) / freq_signal, length.out = length_signal)

  output <- list()
  output[[basename]] <- c(list(time = tm), signals)

  attr(output[[basename]], "info") <- list(alarm = alarm, true = as.logical(true_false), filename = basename, frequency = freq_signal, id = "base", ids = "base")

  if (plot) {
    plot_ecg(output[[basename]])

    # plot.ts(output, nc = 1, main = paste("Output from", basename(filename)))
    # mtext(paste0("tags: ", attr(output, "result")$alarm, ", ", attr(output, "result")$true, " Alarm"), 3, line = 1, adj = 0)
  }

  return(output)
}

#' Read the ECG file generated by WFDB2MAT stored in CSV format.
#'
#' This function reads the tuple data.mat and data.hea that contains the signal and the header with information about
#' the signal.
#'
#' @param filename character vector. Path to the file data. Without the extension .mat. Must exist both .mat and .hea
#'  in the path
#' @param plot a logical value. If the imported file will be plotted. Default is FALSE.
#' @param subset integer sequence. Select only this subset for the dataset. Default is NULL
#' @param classes character vector. Defines which classes will be imported. Default is "all"
#' @param true_alarm logical value or NULL. Select only the TRUE or FALSE alarms. Default is NULL, means all alarms.
#' @param normalize logical value. If TRUE, the signal will be normalized by the baseline and gain. Default is TRUE.
#'
#' @details
#'
#' # Acknowledgment
#'
#' This is a R port from the Matlab's code written by Ikaro Silva, 2014, Version 1.1
#'
#' # Known limitations
#'
#' This function currently does support several of the features described in the WFDB record format (such as
#' multiresolution signals):
#'          http://www.physionet.org/physiotools/wag/header-5.htm
#'  If you are not sure that the record (or database format) you are reading is supported, you can do an integrity
#'  check by comparing the output with RDSAMP.
#'
#'  if(sum(abs(signal-signal2)) !=0);
#'    stop('Record not compatible with RDMAT');
#'  end
#'
#' These tools are available at: https://archive.physionet.org/physiotools/binaries/
#'
#' @return
#' Returns a `list` with the signals and the attributes of the file:
#'
#' - time: timestamp of each observation, in seconds
#' - "signal": the value of the signal on each timestamp. The name of this object is the name of the signal, for
#' example 'II', 'PLETH'.
#'   - signal attributes "info":
#'     - baseline: numeric value
#'     - grain: numeric value
#'     - unit: char
#' - dataset attributes "info":
#'   - alarm: class of alarm, for ex: "Asystole".
#'   - true: if the alarm is true or not, for ex: "False".
#'   - filename: the name of the original file, without the extension.
#'   - frequency: the frequency of the observations, in Hz.
#'
#' @examples
#' \dontrun{
#' signal <- read_ecg("data/a103l")
#' }
#'
read_ecg_csv <- function(filename, plot = FALSE, subset = NULL,
                         classes = c("all", "asystole", "bradycardia", "tachycardia", "fibv", "vtachy"),
                         true_alarm = NULL, normalize = TRUE) {
  checkmate::assert_string(filename, min.chars = 3)
  checkmate::qassert(plot, "B")
  checkmate::qassert(subset, c("0", "X"))
  checkmate::qassert(true_alarm, c("0", "B"))
  checkmate::qassert(normalize, "B")
  classes <- match.arg(classes, several.ok = TRUE)

  if (!("all" %in% classes)) {
    filtered <- NULL

    for (class in classes) {
      res <- switch(class,
        asystole = grep("a\\d*.\\.hea", filename, value = TRUE),
        bradycardia = grep("b\\d*.\\.hea", filename, value = TRUE),
        tachycardia = grep("t\\d*.\\.hea", filename, value = TRUE),
        fibv = grep("f\\d*.\\.hea", filename, value = TRUE),
        vtachy = grep("v\\d*.\\.hea", filename, value = TRUE)
      )

      filtered <- c(filtered, res)
    }

    if (rlang::is_empty(filtered)) {
      message("File skipped (not in class): ", filename)
      return(NULL)
    }
  }

  # Set default parameter values
  def_gain <- 200 # Default value for missing gains
  wfdb_nan <- -32768 # This should be the case for all WFDB signal format types currently supported by RDMAT

  if (tools::file_ext(filename) == "hea") {
    filename <- tools::file_path_sans_ext(filename)
  }

  header <- paste0(filename, ".hea")
  content <- paste0(filename, ".csv.bz2")
  basename <- basename(filename)

  if (any(!file.exists(c(header, content)))) {
    stop("File ", filename, "does not exist.")
  }

  # Following the documentation described in :
  # http://www.physionet.org/physiotools/wag/header-5.htm
  # to parse the header file

  hea <- file(header, "r")
  hea_content <- readLines(hea)
  close(hea)

  # Skip any comment lines
  for (i in seq_along(hea_content)) {
    if (substr(hea_content[i], 1, 1) == "#") {
      next
    } else {
      break
    }
  }

  if (i == length(hea_content)) {
    stop("The file only contains comments.")
  }

  nlines <- length(hea_content)

  hea_content <- strsplit(hea_content[i:length(hea_content)], " ")

  n_signals <- as.numeric(hea_content[[1]][2]) # Number of signals present
  freq_signal <- as.numeric(hea_content[[1]][3]) # Frequency of the signal

  # Process Signal Specification lines. Assumes no comments between lines.
  siginfo <- list()

  for (i in (seq_len(n_signals) + 1)) {
    format <- hea_content[[i]][2]
    gain <- hea_content[[i]][3]
    # Get Signal Units if present
    gain <- unlist(strsplit(gain, "/"))
    unit <- NULL

    # gain_baseline?
    gain_baseline <- unlist(strsplit(gain[1], "\\("))
    if (length(gain_baseline) == 2) {
      gain_baseline <- unlist(strsplit(gain_baseline, "\\)"))
      gain[1] <- gain_baseline[1]
      gain_baseline <- as.numeric(gain_baseline[2])
    } else {
      gain_baseline <- NULL
    }

    if (length(gain) == 2) {
      unit <- gain[2]
      gain <- as.numeric(gain[1])
    } else {
      gain <- as.numeric(gain)

      # if zero set as default
      if (gain == 0) {
        gain <- def_gain
      }
    }

    siginfo[[i - 1]] <- list()

    siginfo[[i - 1]]["format"] <- format # (-32767 +32767) 16+24 == 16 sixteen-bit amplitudes + 24 byte offset
    siginfo[[i - 1]]["gain"] <- gain
    siginfo[[i - 1]]["unit"] <- unit
    siginfo[[i - 1]]["resolution"] <- as.numeric(hea_content[[i]][4]) # bits resolution of the analog-to-digital converter used to digitize the signal
    if (is.null(gain_baseline)) {
      siginfo[[i - 1]]["baseline"] <- as.numeric(hea_content[[i]][5])
    } else {
      siginfo[[i - 1]]["baseline"] <- gain_baseline
    }
    siginfo[[i - 1]]["first"] <- as.numeric(hea_content[[i]][6])
    siginfo[[i - 1]]["chksum"] <- as.numeric(hea_content[[i]][7])
    siginfo[[i - 1]]["blocksize"] <- as.numeric(hea_content[[i]][8])
    siginfo[[i - 1]]["description"] <- hea_content[[i]][9]
  }

  if (nlines != n_signals) {
    alarm <- hea_content[[nlines - 1]][1]
    alarm <- ifelse(substr(alarm, 1, 1) == "#", substring(alarm, 2), alarm)
    true_false <- hea_content[[nlines]][1]
    true_false <- ifelse(substr(true_false, 1, 1) == "#", substring(true_false, 2), true_false)
  }

  if (!is.null(true_alarm)) {
    if (true_alarm != as.logical(true_false)) {
      message("File skipped (alarm is ", !true_alarm, "): ", filename)
      return(NULL)
    }
  }

  csv_content <- readr::read_csv(content, show_col_types = FALSE, col_types = "nnnnnnn")

  # mat_file <- gzfile(content, "rb")
  # mat_content <- R.matlab::readMat(mat_file)
  # close(mat_file)

  signals <- list()
  subset_minmax <- FALSE
  if (!is.null(subset)) {
    subset_minmax <- c(min(subset), max(subset))
  }
  # Convert from digital units to physical units.
  # Mapping should be similar to that of rdsamp.c:
  # http://www.physionet.org/physiotools/wfdb/app/rdsamp.c
  for (i in seq_len(n_signals)) {
    checkmate::assert_true(csv_content[[i]][1] == siginfo[[i]]$first)
    chksum <- (sum(csv_content[[i]]) %% 2^16)
    if (chksum >= 2^15) {
      chksum <- chksum - 2^16
    }
    checkmate::assert_true(chksum == siginfo[[i]]$chksum)

    csv_content[is.na(csv_content[[i]]), i] <- wfdb_nan
    signal <- siginfo[[i]]$description

    if (normalize) {
      signals[[signal]] <- (csv_content[[i]] - siginfo[[i]]$baseline) / siginfo[[i]]$gain
    } else {
      signals[[signal]] <- csv_content[[i]]
    }

    if (!is.null(subset)) {
      signals[[signal]] <- signals[[signal]][subset]
    }

    attr(signals[[signal]], "info") <- list(signal = signal, baseline = siginfo[[i]]$baseline, gain = siginfo[[i]]$gain, unit = siginfo[[i]]$unit, subset = subset_minmax)
  }

  length_signal <- length(signals[[1]])
  # Generate time vector
  tm <- seq(0, (length_signal - 1) / freq_signal, length.out = length_signal)

  output <- list()
  output[[basename]] <- c(list(time = tm), signals)

  attr(output[[basename]], "info") <- list(alarm = alarm, true = as.logical(true_false), filename = basename, frequency = freq_signal, id = "base", ids = "base")

  if (plot) {
    plot_ecg(output[[basename]])

    # plot.ts(output, nc = 1, main = paste("Output from", basename(filename)))
    # mtext(paste0("tags: ", attr(output, "result")$alarm, ", ", attr(output, "result")$true, " Alarm"), 3, line = 1, adj = 0)
  }

  return(output)
}

#' Reads ECG files with annotations.
#'
#' These were converted using python's wfdb library, so the signal is already normalized and
#' converted from digital to physical value range.
#' We need to pay attention to the signal frequency. This first dataset is 200Hz, not 250Hz
#'
#' @param filename character vector. Path to the file data. Without the extension .mat. Must exist both .mat and .hea
#'  in the path
#' @param subset integer sequence. Select only this subset for the dataset. Default is NULL
#' @param classes character vector. Defines which classes will be imported. Default is "all"
#' @param true_alarm logical value or NULL. Select only the TRUE or FALSE alarms. Default is NULL, means all alarms.
#' @param normalize logical value. If TRUE, the signal will be normalized by the baseline and gain. Default is TRUE.
#' @param resample_from integer. If not zero, must be the frequency of the signal in the dataset for resample. E.g.: 200. Default is 0.
#' @param resample_to integer. If not zero, sets the new frequency of the signal. E.g.: 250. Only used if `resample_from` is not zero. Default is 0.
#'

read_ecg_with_atr <- function(filename, subset = NULL, classes = c("all", "persistent_afib", "paroxistical_afib", "non_afib"), resample_from = 0, resample_to = 0) {
  checkmate::assert_string(filename, min.chars = 3)
  classes <- match.arg(classes, several.ok = TRUE)
  checkmate::qassert(resample_from, "X>=0")
  checkmate::qassert(resample_to, "X>=0")

  if (!("all" %in% classes)) {
    filtered <- NULL

    for (class in classes) {
      res <- switch(class,
        persistent_afib = grep("*.\\.per\\.hea", files, value = TRUE),
        paroxistical_afib = grep("*.\\.par\\.hea", files, value = TRUE),
        non_afib = grep("*.\\.non\\.hea", files, value = TRUE)
      )

      filtered <- c(filtered, res)
    }

    if (rlang::is_empty(filtered)) {
      message("File skipped (not in class): ", filename)
      return(NULL)
    }
  }

  if (tools::file_ext(filename) == "hea") {
    filename <- tools::file_path_sans_ext(filename)
  }

  header <- paste0(filename, ".hea")
  content <- paste0(filename, ".csv.bz2")
  annotation <- paste0(filename, ".atr.csv.bz2")
  basename <- basename(filename)

  if (any(!file.exists(c(header, content, annotation)))) {
    stop("File ", filename, "does not exist.")
  }

  hea <- file(header, "r")
  hea_content <- readLines(hea)
  close(hea)

  # Skip any comment lines
  for (i in seq_along(hea_content)) {
    if (substr(hea_content[i], 1, 1) == "#") {
      next
    } else {
      break
    }
  }

  if (i == length(hea_content)) {
    stop("The file only contains comments.")
  }

  nlines <- length(hea_content)

  hea_content <- strsplit(hea_content[i:length(hea_content)], " ")

  n_signals <- as.numeric(hea_content[[1]][2]) # Number of signals present
  freq_signal <- as.numeric(hea_content[[1]][3]) # Frequency of the signal

  # Process Signal Specification lines. Assumes no comments between lines.
  siginfo <- list()

  # Set default parameter values
  def_gain <- 200 # Default value for missing gains
  wfdb_nan <- -32768 # This should be the case for all WFDB signal format types currently supported by RDMAT

  # browser()
  for (i in (seq_len(n_signals) + 1)) {
    format <- hea_content[[i]][2]
    gain <- hea_content[[i]][3]
    # Get Signal Units if present
    gain <- unlist(strsplit(gain, "/"))
    unit <- NULL

    # gain_baseline?
    gain_baseline <- unlist(strsplit(gain[1], "\\("))
    if (length(gain_baseline) == 2) {
      gain_baseline <- unlist(strsplit(gain_baseline, "\\)"))
      gain[1] <- gain_baseline[1]
      gain_baseline <- as.numeric(gain_baseline[2])
    } else {
      gain_baseline <- NULL
    }

    if (length(gain) == 2) {
      unit <- gain[2]
      gain <- as.numeric(gain[1])
    } else {
      gain <- as.numeric(gain)

      # if zero set as default
      if (gain == 0) {
        gain <- def_gain
      }
    }

    siginfo[[i - 1]] <- list()

    siginfo[[i - 1]]["format"] <- format # (-32767 +32767) 16+24 == 16 sixteen-bit amplitudes + 24 byte offset
    siginfo[[i - 1]]["gain"] <- gain
    siginfo[[i - 1]]["unit"] <- unit
    siginfo[[i - 1]]["resolution"] <- as.numeric(hea_content[[i]][4]) # bits resolution of the analog-to-digital converter used to digitize the signal
    if (is.null(gain_baseline)) {
      siginfo[[i - 1]]["baseline"] <- as.numeric(hea_content[[i]][5])
    } else {
      siginfo[[i - 1]]["baseline"] <- gain_baseline
    }
    siginfo[[i - 1]]["first"] <- as.numeric(hea_content[[i]][6])
    siginfo[[i - 1]]["chksum"] <- as.numeric(hea_content[[i]][7])
    siginfo[[i - 1]]["blocksize"] <- as.numeric(hea_content[[i]][8])
    siginfo[[i - 1]]["description"] <- hea_content[[i]][9]
  }

  if (nlines != n_signals) {
    comment <- paste(hea_content[[nlines]], collapse = " ")
    comment <- stringr::str_trim(ifelse(substr(comment, 1, 1) == "#", substring(comment, 2), comment))
  }

  csv_content <- readr::read_csv(content, show_col_types = FALSE, col_types = "nnnnnnn")
  con_names <- names(csv_content)
  csv_content <- as.list(csv_content)
  attributes(csv_content) <- NULL
  names(csv_content) <- con_names
  csv_annotations <- readr::read_csv(annotation, show_col_types = FALSE, col_types = "ncnnncc")
  ann_names <- names(csv_annotations)
  csv_annotations <- as.list(csv_annotations)
  attributes(csv_annotations) <- NULL
  names(csv_annotations) <- ann_names

  signals <- list()
  subset_minmax <- FALSE
  if (!is.null(subset)) {
    subset_minmax <- c(min(subset), max(subset))
  }

  for (i in seq.int(1, length(csv_content))) {
    checkmate::assert_true(siginfo[[i]]$description == names(csv_content[i]))

    if (resample_from > 0) {
      prop <- resample_to / resample_from
      newsignal <- signal::resample(csv_content[[i]], resample_to, resample_from)
      csv_content[[i]] <- newsignal
      freq_signal <- resample_to

      csv_annotations$sample <- csv_annotations$sample * prop
    }

    name <- siginfo[[i]]$description

    if (!is.null(subset)) {
      signals[[name]] <- csv_content[[i]][subset]
    } else {
      signals[[name]] <- csv_content[[i]]
    }

    attr(signals[[name]], "info") <- list(signal = name, baseline = siginfo[[i]]$baseline, gain = siginfo[[i]]$gain, unit = siginfo[[i]]$unit, subset = subset_minmax)
  }

  length_signal <- length(signals[[1]])

  # Generate time vector
  tm <- seq(0, (length_signal - 1) / freq_signal, length.out = length_signal)
  output <- list()
  output[[basename]] <- c(list(time = tm), signals)

  attr(output[[basename]], "info") <- list(regime = comment, filename = basename, frequency = freq_signal, id = "base", ids = "base")
  attr(output[[basename]], "annotations") <- csv_annotations

  return(output)
}

#' Read the ECG files and build a dataset.
#'
#' This function reads the tuple data.mat and data.hea that contains the signal and the header with
#' information about the signal.
#'
#' @param file_paths character vector. Paths to the file data. Without the extension, or ".hea"
#' @param subset integer sequence. Select only this subset for the dataset. Default is NULL
#' @param true_alarm logical value or NULL. Select only the TRUE or FALSE alarms. Default is NULL, means all alarms.
#' @param limit_per_class integer. Limit the size of the dataset by number of the same class. Used
#'                        to speed up the pipeline before the final trial.
#' @param data_type string or NULL. Used only for other datasets that is not the Physionet's 2015
#'                  challenge. Currently, if not `NULL`, it will look also for the annotation files. Default is NULL.
#' @param resample_from integer. If not zero, must be the frequency of the signal in the dataset for resample. E.g.: 200. Default is 0.
#' @param resample_to integer. If not zero, sets the new frequency of the signal. E.g.: 250. Only used if `resample_from` is not zero. Default is 0.
#'
#' @return
#' Returns a `list` with the signals and the attributes of the file:
#'
#' - time: timestamp of each observation, in seconds
#' - "signal": the value of the signal on each timestamp. The name of this object is the name of the signal, for
#' example 'II', 'PLETH'.
#'   - signal attributes "info":
#'     - baseline: numeric value
#'     - grain: numeric value
#'     - unit: char
#' - dataset attributes "info":
#'   - alarm: class of alarm, for ex: "Asystole".
#'   - true: if the alarm is true or not, for ex: "False".
#'   - filename: the name of the original file, without the extension.
#'   - frequency: the frequency of the observations, in Hz.
#'

read_and_prepare_ecgs <- function(file_paths, subset = NULL, true_alarm = NULL, limit_per_class = NULL, data_type = NULL, resample_from = 0, resample_to = 0, normalize = FALSE) {
  checkmate::qassert(file_paths, "S+")
  checkmate::qassert(subset, c("0", "X"))
  checkmate::qassert(true_alarm, c("0", "B"))
  checkmate::qassert(data_type, c("0", "S1"))
  checkmate::qassert(resample_from, "X>=0")
  checkmate::qassert(resample_to, "X>=0")


  result <- list()
  classes <- list()

  for (file in file_paths) {
    # get the filename without the extension
    filename <- tools::file_path_sans_ext(basename(file))


    it <- NULL

    if (is.null(data_type)) {
      # If data_type is NULL (default), read the false.alarm dataset

      if (is.numeric(limit_per_class)) {

        # the class is the first character of the file
        class <- substr(filename, 1, 1)

        if (is.null(classes[[class]])) {
          classes[[class]] <- 1
        } else {
          classes[[class]] <- classes[[class]] + 1
        }

        if (classes[[class]] > limit_per_class) {
          next
        }
      }

      it <- read_ecg_csv(file,
        subset = subset,
        true_alarm = true_alarm,
        normalize = normalize
      )
    } else {
      # Else, reads the other dataset

      if (is.numeric(limit_per_class)) {
        # The class in this case is the "second" extension
        class <- tools::file_ext(filename)

        if (is.null(classes[[class]])) {
          classes[[class]] <- 1
        } else {
          classes[[class]] <- classes[[class]] + 1
        }

        if (classes[[class]] > limit_per_class) {
          next
        }
      }

      it <- read_ecg_with_atr(file,
        subset = subset,
        resample_from = resample_from, resample_to = resample_to
      )
    }

    # Keep only those which where correctly imported
    if (!is.null(it)) {
      result[filename] <- it
    }
  }

  return(result)
}

#' Reshape dataset by true and false alarms
#'
#' The resulting dataset can be filtered so every file as all the given signals, or
#' at least one of the signals.
#'
#' @param dataset a `list` that contains all imported files.
#' @param signals character vector. The signals we want to keep. E.g.: c("I", "II")
#' @param all_signals a `logical` value. If TRUE, each file in dataset must have all the signals
#'                    defined. Default is TRUE.
#'
#'

reshape_ds_by_truefalse <- function(dataset, signals, all_signals = TRUE) {
  checkmate::qassert(dataset, "L+")
  checkmate::qassert(signals, "S+")
  checkmate::qassert(all_signals, "B")

  # divide in TRUE and FALSE
  df_true <- purrr::keep(dataset, ~ attr(.x, "info")$true)
  df_false <- purrr::keep(dataset, ~ !attr(.x, "info")$true)

  # filter by presence of signals
  if (all_signals) {
    df_true <- purrr::keep(df_true, ~ all(signals %in% names(.x)))
    df_false <- purrr::keep(df_false, ~ all(signals %in% names(.x)))
  } else {
    df_true <- purrr::keep(df_true, ~ any(signals %in% names(.x)))
    df_false <- purrr::keep(df_false, ~ any(signals %in% names(.x)))
  }

  # Convert from list by file to list by signal
  df_true <- purrr::transpose(df_true)
  df_false <- purrr::transpose(df_false)

  # keep only the signals we want
  df_true <- df_true[signals]
  df_false <- df_false[signals]

  # convert trues and falses into a tibble for later use on `rsample`
  # NOTE: here we create a dummy variable "class_alarm" to stratify the sampling
  # because the `rsample` package does not accept more than one variable for stratification.
  df_true <- purrr::map(df_true, function(x) {
    y <- purrr::compact(x) # remove files that don't have the signal
    files <- names(y)
    classes <- factor(substr(files, 1, 1), c("a", "b", "t", "f", "v"))
    result <- tibble::tibble(
      file = files, class = classes, values = y, alarm = factor("true", c("true", "false"))
    )
    result %>% dplyr::mutate(class_alarm = paste0(class, "_", alarm)) # create the dummy variable
  })

  df_false <- purrr::map(df_false, function(x) {
    y <- purrr::compact(x) # remove files that don't have the signal
    files <- names(y)
    classes <- factor(substr(files, 1, 1), c("a", "b", "t", "f", "v"))
    result <- tibble::tibble(
      file = files, class = classes, values = y, alarm = factor("false", c("true", "false"))
    )
    result %>% dplyr::mutate(class_alarm = paste0(class, "_", alarm)) # create the dummy variable
  })

  data <- purrr::map2(df_true, df_false, dplyr::bind_rows)

  return(data)
}
