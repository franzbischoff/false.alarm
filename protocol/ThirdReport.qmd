#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
knitr::opts_chunk$set(
  echo = FALSE, fig.align = "center", autodep = TRUE,
  fig.height = 5, fig.width = 10,
  tidy = "styler",
  tidy.opts = list(strict = TRUE)
)
if (knitr::is_latex_output()) {
  knitr::opts_chunk$set(dev = "pdf")
} else {
  knitr::opts_chunk$set(dev = "svg")
}

my_graphics <- function(image_name, base_path = here::here("docs", "figure")) {
  file_path <- glue::glue("{base_path}/{image_name}")

  if (knitr::is_latex_output()) {
    if (file.exists(glue::glue("{file_path}.pdf"))) {
      file_path <- glue::glue("{file_path}.pdf")
    } else if (file.exists(glue::glue("{file_path}.png"))) {
      file_path <- glue::glue("{file_path}.png")
    } else {
      file_path <- glue::glue("{file_path}.jpg")
    }
  } else {
    if (file.exists(glue::glue("{file_path}.svg"))) {
      file_path <- glue::glue("{file_path}.svg")
    } else if (file.exists(glue::glue("{file_path}.png"))) {
      file_path <- glue::glue("{file_path}.png")
    } else {
      file_path <- glue::glue("{file_path}.jpg")
    }
  }

  knitr::include_graphics(file_path)
}

my_kable <- function(title, label, content) {
  res <- glue(r"(<br><table class="tg"><caption>)", "(\\#tab:{label}) {title}", r"(</caption>{content}</table>)")
  out <- structure(res, format = "html", class = "knitr_kable")
  attr(out, "format") <- "html"
  out
}

tkplot <- function(object, interactive = FALSE, res = 50) {
  ecg <- read_ecg_with_atr(here::here("inst/extdata/afib_regimes", object$record), resample_from = 200, resample_to = res)
  value <- ecg[[1]]$II
  prop <- 250 / res
  mask <- seq.int(50, 100)
  value[1:5] <- median(value[mask])
  value[(length(value) - 5):length(value)] <- median(value[mask])
  time <- seq(1, floor(length(value) * prop), length.out = length(value))
  data <- tibble::tibble(time = time, value = value)
  min_data <- min(data$value)
  max_data <- max(data$value)
  truth <- clean_truth(floor(attr(ecg[[1]], "regimes") * prop), floor(length(value) * prop)) # object$truth[[1]]
  preds <- object$pred[[1]]

  title <- glue::glue(
    "Recording: {object$record} ",
    "#truth: {length(truth)}, ",
    "#preds: {length(preds)}, ",
    "length: {floor(length(value)*prop)} ",
    "FLOSS Score: {round(object$score, 3)}"
  )

  subtitle <- glue::glue(
    "Parameters: ",
    "MP window: {object$window_size}, ",
    "MP threshold: {object$mp_threshold}, ",
    "Time constraint: {object$time_constraint}, ",
    "Regime threshold: {object$regime_threshold}, ",
    "Regime landmark: {object$regime_landmark}"
  )


  plot <- data %>%
    timetk::plot_time_series(
      time, value,
      .title = glue::glue(title, "<br><sup>{subtitle}</sup>"),
      .interactive = interactive,
      .smooth = FALSE,
      .line_alpha = 0.3,
      .line_size = 0.2,
      .plotly_slider = interactive
    )

  if (interactive) {
    plot <- plot %>%
      plotly::add_segments(
        x = preds, xend = preds, y = min_data,
        yend = max_data * 1.1,
        line = list(width = 2.5, color = "#0108c77f"),
        name = "Predicted"
      ) %>%
      plotly::add_segments(
        x = truth, xend = truth, y = min_data,
        yend = max_data,
        line = list(width = 2.5, color = "#ff00007f"),
        name = "Truth"
      )
  } else {
    plot <- plot +
      ggplot2::geom_segment(
        data = tibble::tibble(tru = truth),
        aes(
          x = tru, xend = tru,
          y = min_data, yend = max_data - (max_data - min_data) * 0.1
        ), linewidth = 2, color = "#ff00007f"
      ) +
      ggplot2::geom_segment(
        data = tibble::tibble(pre = preds),
        aes(
          x = pre, xend = pre,
          y = min_data, yend = max_data
        ), linewidth = 1, color = "#0108c77f"
      ) +
      ggplot2::theme_bw() +
      ggplot2::theme(
        legend.position = "none",
        plot.margin = margin(0, 0, 0, 10)
      ) +
      ggplot2::labs(title = title, subtitle = subtitle, y = ggplot2::element_blank())
  }
  plot
}

options(dplyr.summarise.inform = FALSE)

# tinytex::tlmgr_install("tabu")
library(here)
library(glue)
library(visNetwork)
library(tibble)
library(kableExtra)
library(patchwork)
library(targets)
library(ggplot2)

source(here::here("scripts", "common", "read_ecg.R"))

knitr::opts_knit$set(
  root.dir = here("docs"),
  base.dir = here("protocol"),
  verbose = TRUE
)
#
#
#
cat(glue::glue("Knitting as latex? ", knitr::is_latex_output()))
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "Example of pipeline visualization using `targets`.
#|  From left to right we see 'Stems' (steps that do not create branches) and 'Patterns'
#|  (that contains two or more branches) and the flow of the information.
#|  The green color means that the step is up to date to the current code and dependencies."

my_graphics("targets")
#
#
#
#
#
#
#
#| fig-cap: "Fraction of the website generated by `workflowr`.
#|  On top we see that this version passed all checks, and in the middle we see a table
#|  referring to the previous versions of the report.."
my_graphics("workflowr_print")
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "A distance matrix (top), and a matrix profile (bottom). The matrix profile stores only
#|  the minimum values of the distance matrix."
#| out.width: 33%
my_graphics("mp_1")
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| label: tbl-alarms
#| tbl-cap: "The alarms we seek to identify."

alarms <- tribble(
  ~Alarm, ~Definition,
  "Asystole", "No QRS for at least 4 seconds",
  "Extreme Bradycardia", "Heart rate lower than 40 bpm for 5 consecutive beats",
  "Extreme Tachycardia", "Heart rate higher than 140 bpm for 17 consecutive beats",
  "Ventricular Tachycardia", "5 or more ventricular beats with heart rate higher than 100 bpm",
  "Ventricular Flutter/Fibrillation", "Fibrillatory, flutter, or oscillatory waveform for at least 4 seconds"
)

kable(alarms,
  booktabs = TRUE,
  longtable = TRUE,
  align = "ll",
  position = "ht",
  linesep = ""
) %>%
  row_spec(0, bold = TRUE) %>%
  column_spec(1:2, width = "20em")
#
#
#
#
#
#
#
#| label: tbl-challenge
#| tbl-cap: "Challenge Results on real-time data. The scores were multiplied by 100."
challenge <- tribble(
  ~Score, ~Authors,
  "81.39", "Filip Plesinger, Petr Klimes, Josef Halamek, Pavel Jurak",
  "79.44", "Vignesh Kalidas",
  "79.02", "Paula Couto, Ruben Ramalho, Rui Rodrigues",
  "76.11", "Sibylle Fallet, Sasan Yazdani, Jean-Marc Vesin",
  "75.55", "Christoph Hoog Antink, Steffen Leonhardt"
)

kable(challenge,
  booktabs = TRUE,
  longtable = TRUE,
  align = "cl",
  position = "ht",
  linesep = ""
) %>%
  row_spec(0, bold = TRUE) %>%
  column_spec(1:2, width = "20em")
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| label: tbl-criteria
#| tbl-cap: "Literature review criteria."

criteria <- tribble(
  ~"Inclusion criteria", ~"Exclusion criteria",
  "ECG automatic interpretation", "Manual interpretation",
  "ECG anomaly detection", "Publication older than ten years",
  "ECG context change detection", "Do not attempt to identify life-threatening arrhythmias, namely asystole, extreme bradycardia, extreme tachycardia, ventricular tachycardia, and ventricular flutter/fibrillation",
  "Online Stream ECG analysis", "No performance measurements reported",
  "Specific diagnosis (like a flutter, hyperkalemia, etc.)", ""
)

kable(criteria,
  booktabs = TRUE,
  longtable = TRUE,
  align = "ll",
  position = "ht",
  linesep = "\\addlinespace"
) %>%
  row_spec(0, bold = TRUE) %>%
  column_spec(1:2, width = "22em")

#
#
#
#
#
#
#
#| fig-cap: "Flowchart of the literature survey."
my_graphics("PRISMA")
#
#
#
#
#
#
#
#| label: tbl-kappa
#| tbl-cap: "Reliability on the literature survey process."
#|
if (knitr::is_latex_output()) {
  cat(r"(
\begin{table}[ht]
\centering
\begin{tabular}{llcclcc}
\toprule
                                                  &                             & \multicolumn{2}{c}{\textbf{\begin{tabular}[c]{@{}c@{}}Title-Abstract\\ (2388 articles)\end{tabular}}} & \textbf{} & \multicolumn{2}{c}{\textbf{\begin{tabular}[c]{@{}c@{}}Full-Review\\ (303 articles)\end{tabular}}} \\ \cline{3-4} \cline{6-7}
                                                  &                             & \multicolumn{2}{c}{Reviewer \#2}                                                                      &           & \multicolumn{2}{c}{Reviewer \#2}                                                                  \\ \cline{3-4} \cline{6-7}
                                                  &                             & \multicolumn{1}{l}{Include}                       & \multicolumn{1}{l}{Exclude}                       &           & \multicolumn{1}{l}{Include}                     & \multicolumn{1}{l}{Exclude}                     \\ \hline
\multicolumn{1}{r}{\multirow{2}{*}{Reviewer \#1}} & \multicolumn{1}{r}{Include} & 185                                               & 381                                               &           & 63                                              & 58                                              \\
\multicolumn{1}{r}{}                              & \multicolumn{1}{r}{Exclude} & 129                                               & 1693                                              &           & 13                                              & 169                                             \\ \hline
Cohen's omnibus  $\kappa$                         &                             & \multicolumn{2}{c}{0.30}                                                                              &           & \multicolumn{2}{c}{0.48}                                                                          \\
Maximum possible $\kappa$                         &                             & \multicolumn{2}{c}{0.66}                                                                              &           & \multicolumn{2}{c}{0.67}                                                                          \\
Std Err for $\kappa$                              &                             & \multicolumn{2}{c}{0.02}                                                                              &           & \multicolumn{2}{c}{0.05}                                                                          \\
Observed Agreement                                &                             & \multicolumn{2}{c}{79\%}                                                                              &           & \multicolumn{2}{c}{77\%}                                                                          \\
Random Agreement                                  &                             & \multicolumn{2}{c}{69\%}                                                                              &           & \multicolumn{2}{c}{55\%}                                                                          \\ \hline\addlinespace
\multicolumn{2}{l}{\textbf{Agreement corrected with KappaAcc}}          & \multicolumn{2}{c}{\textbf{82\%}}                                                                     & \textbf{} & \multicolumn{2}{c}{\textbf{85\%}}                                                                 \\ \bottomrule
\end{tabular}
\end{table}
)")
} else {
  my_kable(
    title = "Inter-rater Reliability on the literature survey process.",
    label = "kappa",
    content = r"(<thead> <tr> <th class="tg-top" colspan="2"> </th> <th class="tg-top"
colspan="2"> Title-Abstract<br>(2388 articles) </th> <th class="tg-top"> </th> <th class="tg-top"
colspan="2"> Full-Review<br>(303 articles) </th> </tr></thead> <tbody> <tr> <td class="tg-73oq"
colspan="2"> </td><td class="tg-wp8o" colspan="2"> Reviewer #2 </td><td class="tg-73oq"> </td><td
class="tg-wp8o" colspan="2"> Reviewer #2 </td></tr><tr> <td class="tg-73oq" colspan="2"> </td><td
class="tg-73oq"> Include </td><td class="tg-73oq"> Exclude </td><td class="tg-73oq"> </td><td
class="tg-73oq"> Include </td><td class="tg-73oq"> Exclude </td></tr><tr> <td class="tg-wp8o"
rowspan="2"> Reviewer #1 </td><td class="tg-cross"> Include </td><td class="tg-cross"> 185 </td><td
class="tg-cross"> 381 </td><td class="tg-cross"> </td><td class="tg-cross"> 63 </td><td
class="tg-cross"> 58 </td></tr><tr> <td class="tg-crosslow"> Exclude </td><td class="tg-crosslow"> 129
</td><td class="tg-crosslow"> 1693 </td><td class="tg-crosslow"> </td><td class="tg-crosslow"> 13
</td><td class="tg-crosslow"> 169 </td></tr><tr> <td class="tg-73oq" colspan="2"> Cohenâ€™s omnibus
<span class="math inline">\(\kappa\)</span> </td><td class="tg-body" colspan="2"> 0.30 </td><td
class="tg-body"> </td><td class="tg-body" colspan="2"> 0.48 </td></tr><tr> <td class="tg-73oq"
colspan="2"> Maximum possible <span class="math inline">\(\kappa\)</span> </td><td class="tg-body"
colspan="2"> 0.66 </td><td class="tg-body"> </td><td class="tg-body" colspan="2"> 0.67
</td></tr><tr> <td class="tg-73oq" colspan="2"> Std Err for <span class="math
inline">\(\kappa\)</span> </td><td class="tg-body" colspan="2"> 0.02 </td><td class="tg-body">
</td><td class="tg-body" colspan="2"> 0.05 </td></tr><tr> <td class="tg-73oq" colspan="2"> Observed
Agreement </td><td class="tg-body" colspan="2"> 79% </td><td class="tg-body"> </td><td
class="tg-body" colspan="2"> 77% </td></tr><tr> <td class="tg-73oq" colspan="2"> Random Agreement
</td><td class="tg-body" colspan="2"> 69% </td><td class="tg-body"> </td><td class="tg-body"
colspan="2"> 55% </td></tr><tr> <td class="tg-mcqj" colspan="2"> Agreement corrected with KappaAcc
</td><td class="tg-mqa1" colspan="2"> 82% </td><td class="tg-mcqj"> </td><td class="tg-mqa1"
colspan="2"> 85% </td></tr></tbody>)"
  )
}
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "RAW output from Arduino at ~300hz"
my_graphics("arduino_plot")
#
#
#
#
#
#| fig-cap: "Gray is RAW, Red is filtered"
my_graphics("filtered_ecg")
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "Green line is the \"complexity\" of the signal"
my_graphics("noise")
#
#
#
do_create <- FALSE

if (knitr::is_latex_output()) {
  if (!file.exists(here("docs/figure/regime_filter.pdf"))) {
    do_create <- TRUE
  }
} else {
  if (!file.exists(here("docs/figure/regime_filter.svg"))) {
    do_create <- TRUE
  }
}

if (do_create) {
  source(here("scripts", "common", "read_ecg.R"))
  source(here("scripts", "common", "sqi.R"))
  filter_w <- 200
  limit <- 8
  file <- "a104s"
  size_w <- 16
  size_h <- 5

  if (file.exists(here("output", "createfilter.rds"))) {
    data <- readRDS(here("output", "createfilter.rds"))
  } else {
    data <- read_ecg_csv(here(glue("inst/extdata/physionet/{file}.hea")))
    data <- data[[file]]$II
    saveRDS(data, here("output/createfilter.rds"), compress = "xz")
  }

  norm_data <- tsmp:::znorm(data)
  filter <- win_complex(norm_data, filter_w)
  filter <- filter > limit

  if (knitr::is_latex_output()) {
    grDevices::pdf(here("docs/figure/regime_filter.pdf"),
      width = size_w, height = size_h
    )
  } else {
    svglite::svglite(here("docs/figure/regime_filter.svg"),
      width = size_w, height = size_h
    )
  }
  plot(norm_data, main = "", type = "l", ylab = "", xlab = "index", lwd = 0.2)
  points(cbind(which(filter), 0), col = "blue", pch = 19)
  dev.off()
}
#
#
#
#
#
#| fig-cap: "Noisy data marked by the \"complexity\" filter"
my_graphics("regime_filter")
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "FLUSS algorithm, using arc counts."
my_graphics("fluss_arcs")
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "Top to bottom: two weakly-labeled snippets of a larger time series. T(-) contains
#|  only normal beats. T(+) also contains PVC (premature ventricular contractions).
#|  Next, two Matrix Profiles with window size 91; AB-join is in red and self-join in blue.
#|  Bottom, the Contrast Profile showing the highest location."

my_graphics("contrast")
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "Nested resampling.
#|  The full dataset is resampled several times (outer resampling), so each branch has its
#|  own Test set (yellow). On each branch, the Training set is used as if it were a full dataset,
#|  being resampled again (inner resampling); here the Assessment set (blue) is used to test the
#|  learning model and tune parameters. The best model then, is finally evaluated on its own
#|  Test set."

my_graphics("draw-nested-resampling")
#
#
#
#
#
#
#
#
#
#| fig-cap: "Pipeline for regime change detection.
#|  The full dataset (containing several patients) is divided on a Training set and a Test set.
#|  The Training set is then resampled in an Analysis set and an Assessment set. The former is
#|  used for training/parameter tuning and the latter for assessing the result. The best parameters
#|  are then used for evaluation on the Test set. This may be repeated several times."

my_graphics("draw-regime-model")
#
#
#
#
#
#
#
#
#
#| fig-cap: "Pipeline for alarm classification.
#|  The full dataset (containing several patients) is grouped by class and by TRUE/FALSE alarm.
#|  This grouping allows resampling to keep a similar frequency of classes and TRUE/FALSE of the full dataset.
#|  Then the full dataset is divided on a Training set and a Test set.
#|  The Training set is then resampled in an Analysis set and an Assessment set. The former is
#|  used for extracting shapelets, training the model and parameter tuning; the latter for assessing
#|  the performance of the model. Finally, the best model is evaluated on the Test set.
#|  This may be repeated several times."

my_graphics("draw-classif-model")
#
#
#
#
#
#| fig-cap: "Pipeline of the final process.
#|  The streaming data, coming from one patient, is processed to create its Matrix Profile.
#|  Then, the FLOSS algorithm is computed for detecting a regime change. When a new regime is
#|  detected, a sample of this new regime is analysed by the model and a decision is made. If
#|  the new regime is life-threatening, the alarm will be fired."

my_graphics("draw-global-model")
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "Regime change evaluation. The top line illustrates the ground truth, and the
#|  bottom line the locations reported by the algorithm. Note that multiple proposed locations
#|  can be mapped to a single ground truth point."

my_graphics("floss_eval")
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
network <- readRDS(here::here("output", "regime_network.rds"))
net <- network |>
  visNetwork::visPhysics(hierarchicalRepulsion = list(
    springLength = 1,
    avoidOverlap = 0.5,
    nodeDistance = 120
  ))
#
#
#
if (knitr::is_latex_output()) {
  my_graphics("the-network")
} else {
  visNetwork::visInteraction(net, hover = TRUE, multiselect = TRUE, tooltipDelay = 100)
}
#
#
#
#| fig-cap: "Regime change detection example.
#|  The graph on top shows the ECG streaming; the blue line marks the ten seconds
#|  before the original alarm was fired; the red line marks the time constraint of 1250;
#|  the dark red line marks the limit for taking a decision in this case of Asystole
#|  the blue horizontal line represents the size of the sliding window.
#|  The graph on the middle shows the Arc counts as seen by the algorithm (with the corrected
#|  distribution); the red line marks the current minimum value and its index; the blue
#|  horizontal line shows the minimum value seen until then.
#|  The graph on the bottom shows the computed Arc counts (raw) and the red line is the
#|  theoretical distribution used for correction."
my_graphics("floss_regime")
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "Variable interactions strength using feature importance ranking measure (FIRM) approach [@Greenwell2018].
#|  A) Shows strong interaction between `regime_threshold` and `regime_landmark`, `mp_threshold` and `window_size`,
#|     `mp_threshold` and `regime_landmark`.
#|  B) Refitting the model with these interactions taken into account, the strength is substantially reduced, except
#|     for the first, showing that indeed there is a strong correlation between those variables."

interactions <- readRDS(here("output", "importances_lmk.rds"))
importance_firm <- interactions$importance_firm
importance_perm <- interactions$importance_perm
importance_shap <- interactions$importance_shap
shap_html_test <- interactions$shap_html_test
shap_fastshap_all_test <- interactions$shap_fastshap_all_test
interactions <- interactions$interactions

interactions2 <- readRDS(here("output", "importances2_lmk.rds"))
importance_firm2 <- interactions2$importance_firm2
importance_perm2 <- interactions2$importance_perm2
importance_shap2 <- interactions2$importance_shap2
shap_fastshap_all_test2 <- interactions2$shap_fastshap_all_test2
shap_html_test2 <- interactions2$shap_html_test2
interactions2 <- interactions2$interactions2

interactions_plot <- ggplot2::ggplot(interactions, ggplot2::aes(
  x = reorder(Variables, Interaction),
  y = Interaction, fill = Variables
)) +
  ggplot2::geom_col(color = "grey35", linewidth = 0.2) +
  ggplot2::coord_flip() +
  ggplot2::labs(
    title = "Normal fit",
    y = ggplot2::element_blank(),
    x = ggplot2::element_blank()
  ) +
  ggplot2::ylim(0, 1.65) +
  ggplot2::theme_bw() +
  ggplot2::theme(legend.position = "none")

interactions2_plot <- ggplot2::ggplot(interactions2, ggplot2::aes(
  x = reorder(Variables, Interaction),
  y = Interaction, fill = Variables
)) +
  ggplot2::geom_col(color = "grey35", linewidth = 0.2) +
  ggplot2::coord_flip() +
  ggplot2::labs(
    title = "Taking into account the interactions",
    y = "Interaction strength",
    x = ggplot2::element_blank()
  ) +
  ggplot2::ylim(0, 1.65) +
  ggplot2::theme_bw() +
  ggplot2::theme(legend.position = "none")

inter <- interactions_plot / interactions2_plot
inter + plot_annotation(
  title = "Variable Interaction Strength",
  tag_levels = c("A", "1"),
  theme = ggplot2::theme_bw()
)
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "Variables importances using three different methods. A) Feature Importance Ranking Measure
#|  using ICE curves. B) Permutation method. C) SHAP (400 iterations). Line 1 refers to the original
#|  fit, and line 2 to the re-fit, taking into account the interactions between variables
#|  (@fig-interaction)."


importance_firm_plot <- ggplot2::ggplot(importance_firm, aes(
  x = reorder(Variable, Importance),
  y = Importance, fill = Variable
)) +
  ggplot2::geom_col(colour = "grey35", linewidth = 0.8, show.legend = FALSE) +
  ggplot2::coord_flip() +
  ggplot2::labs(
    title = "Feature Importance Ranking Measure",
    subtitle = "Individual Conditional Expectation",
    x = "",
    y = ggplot2::element_blank()
  ) +
  ggplot2::ylim(0, 3.5) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = "none",
    plot.margin = margin(0, 0, 0, 10)
  )

importance_perm_plot <- ggplot2::ggplot(importance_perm, aes(
  x = reorder(Variable, Importance),
  y = Importance, fill = Variable
)) +
  ggplot2::geom_boxplot(colour = "grey35", linewidth = 0.5, show.legend = FALSE) +
  ggplot2::coord_flip() +
  ggplot2::labs(
    title = "Permutation-based (100x)",
    x = "",
    y = ggplot2::element_blank()
  ) +
  ggplot2::ylim(2, 15) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = "none",
    plot.margin = margin(0, 0, 0, 10)
  )

importance_shap_plot <- ggplot2::ggplot(importance_shap, aes(
  x = reorder(Variable, Importance),
  y = Importance, fill = Variable
)) +
  ggplot2::geom_col(colour = "grey35", linewidth = 0.8, show.legend = FALSE) +
  ggplot2::coord_flip() +
  ggplot2::labs(
    title = "SHAP (400 iterations)",
    x = "",
    y = ggplot2::element_blank()
  ) +
  ggplot2::ylim(0, 1.6) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = "none",
    plot.margin = margin(0, 0, 0, 10)
  )

importance_firm2_plot <- ggplot2::ggplot(importance_firm2, aes(
  x = reorder(Variable, Importance),
  y = Importance, fill = Variable
)) +
  ggplot2::geom_col(colour = "grey35", linewidth = 0.8, show.legend = FALSE) +
  ggplot2::coord_flip() +
  ggplot2::labs(
    x = "",
    y = "Importance"
  ) +
  ggplot2::ylim(0, 3.5) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = "none",
    plot.margin = margin(0, 0, 0, 10)
  )

importance_perm2_plot <- ggplot2::ggplot(importance_perm2, aes(
  x = reorder(Variable, Importance),
  y = Importance, fill = Variable
)) +
  ggplot2::geom_boxplot(colour = "grey35", linewidth = 0.5, show.legend = FALSE) +
  ggplot2::coord_flip() +
  ggplot2::labs(
    x = "",
    y = "Importance"
  ) +
  ggplot2::ylim(2, 15) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = "none",
    plot.margin = margin(0, 0, 0, 10)
  )

importance_shap2_plot <- ggplot2::ggplot(importance_shap2, aes(
  x = reorder(Variable, Importance),
  y = Importance, fill = Variable
)) +
  ggplot2::geom_col(colour = "grey35", linewidth = 0.8, show.legend = FALSE) +
  ggplot2::coord_flip() +
  ggplot2::labs(
    x = "",
    y = "Importance"
  ) +
  ggplot2::ylim(0, 1.6) +
  ggplot2::theme_bw() +
  ggplot2::theme(
    legend.position = "none",
    plot.margin = margin(0, 0, 0, 10)
  )


all <- (importance_firm_plot / importance_firm2_plot + plot_layout(tag_level = "new")) |
  (importance_perm_plot / importance_perm2_plot + plot_layout(tag_level = "new")) |
  (importance_shap_plot / importance_shap2_plot + plot_layout(tag_level = "new")) +
    plot_layout(guides = "collect")
all + plot_annotation(
  title = "Variable importances",
  tag_levels = c("A", "1"),
  theme = ggplot2::theme_bw() + ggplot2::theme(
    plot.title = ggplot2::element_text(size = 20)
  )
)
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "This shows the effect each variable has on the FLOSS score. This plot doesn't take into account the
#|  variable interactions."

trained_model <- readRDS(here("output", "dbarts_fitted_lmk.rds"))
train_data <- trained_model$training_data
testing_data <- trained_model$testing_data
predictors_names <- c("time_constraint", "regime_threshold", "mp_threshold", "window_size", "regime_landmark")
outcome_name <- "mean"

testing_data2 <- testing_data %>%
  dplyr::mutate(
    int_rt_rl = regime_threshold * regime_landmark,
    int_mp_w = mp_threshold * window_size,
    int_mp_rl = mp_threshold * regime_landmark,
    # int_mp_rt = mp_threshold * regime_threshold
    # int_mp_tc = mp_threshold * time_constraint
    .before = mean
  )

layout <- "
AABB
CCDD
#EE#
"
# all <- t1 + t2 + t3 + t4 + t5 +
#   plot_layout(design = layout, guides = "collect")

# all + plot_annotation(
#   title = "Shapley value vs. variable values",
#   subtitle = "Original fit",
#   theme = ggplot2::theme_bw()
# )

d1 <- shapviz::shapviz(shap_fastshap_all_test, X = testing_data[, predictors_names], baseline = mean(testing_data[, outcome_name]$mean))
a1 <- shapviz::sv_dependence(d1, "window_size", color_var = "auto") +
  ggplot2::geom_smooth(method = loess, colour = "#0000ff44", alpha = 0.2) +
  ggplot2::labs(y = ggplot2::element_blank()) +
  ggplot2::theme_bw()
a2 <- shapviz::sv_dependence(d1, "regime_threshold", color_var = "auto") +
  ggplot2::geom_smooth(method = loess, colour = "#0000ff44", alpha = 0.2) +
  ggplot2::labs(y = ggplot2::element_blank()) +
  ggplot2::theme_bw()
a3 <- shapviz::sv_dependence(d1, "regime_landmark", color_var = "auto") +
  ggplot2::geom_smooth(method = loess, colour = "#0000ff44", alpha = 0.2) +
  ggplot2::labs(y = ggplot2::element_blank()) +
  ggplot2::theme_bw()
a4 <- shapviz::sv_dependence(d1, "mp_threshold", color_var = "auto") +
  ggplot2::geom_smooth(method = loess, colour = "#0000ff44", alpha = 0.2) +
  ggplot2::labs(y = ggplot2::element_blank()) +
  ggplot2::theme_bw()
a5 <- shapviz::sv_dependence(d1, "time_constraint", color_var = "auto") +
  ggplot2::geom_smooth(method = loess, colour = "#0000ff44", alpha = 0.2) +
  ggplot2::labs(y = ggplot2::element_blank()) +
  ggplot2::theme_bw()

all2 <- ((a1 + a5 + a3 + a4 +
  plot_layout(guides = "collect")) +
  (a2 + plot_layout(guides = "collect")))
all2 + plot_layout(design = layout) + plot_annotation(
  title = "Shapley value vs. variable values",
  theme = ggplot2::theme_bw()
)
#
#
#
#| fig-cap: "This shows the effect each variable has on the FLOSS score, taking into account the interactions."

# t1 <- autoplot(shap_fastshap_all_test2,
#   type = "dependence",
#   X = testing_data2, feature = predictors_names[2], alpha = 0.2
# ) + ggplot2::geom_smooth(method = loess) + ggplot2::labs(y = ggplot2::element_blank()) + ggplot2::theme_bw()
# t2 <- autoplot(shap_fastshap_all_test2,
#   type = "dependence",
#   X = testing_data2, feature = predictors_names[1], alpha = 0.2
# ) + ggplot2::geom_smooth(method = loess) + ggplot2::labs(y = ggplot2::element_blank()) + ggplot2::theme_bw()
# t3 <- autoplot(shap_fastshap_all_test2,
#   type = "dependence",
#   X = testing_data2, feature = predictors_names[4], alpha = 0.2
# ) + ggplot2::geom_smooth(method = loess) + ggplot2::labs(y = ggplot2::element_blank()) + ggplot2::theme_bw()
# t4 <- autoplot(shap_fastshap_all_test2,
#   type = "dependence",
#   X = testing_data2, feature = predictors_names[3], alpha = 0.2
# ) + ggplot2::geom_smooth(method = loess) + ggplot2::labs(y = ggplot2::element_blank()) + ggplot2::theme_bw()
# t5 <- autoplot(shap_fastshap_all_test,
#   type = "dependence",
#   X = testing_data2, feature = predictors_names[5], alpha = 0.2
# ) + ggplot2::geom_smooth(method = loess) + ggplot2::labs(y = ggplot2::element_blank()) + ggplot2::theme_bw()


layout <- "
AABB
CCDD
#EE#
"


d1 <- shapviz::shapviz(shap_fastshap_all_test2, X = testing_data2[, predictors_names], baseline = mean(testing_data2[, outcome_name]$mean))
a1 <- shapviz::sv_dependence(d1, "window_size", color_var = "auto") +
  ggplot2::geom_smooth(method = loess, colour = "#0000ff44", alpha = 0.2) +
  ggplot2::labs(y = ggplot2::element_blank()) +
  ggplot2::theme_bw()
a2 <- shapviz::sv_dependence(d1, "regime_threshold", color_var = "auto") +
  ggplot2::geom_smooth(method = loess, colour = "#0000ff44", alpha = 0.2) +
  ggplot2::labs(y = ggplot2::element_blank()) +
  ggplot2::theme_bw()
a3 <- shapviz::sv_dependence(d1, "regime_landmark", color_var = "auto") +
  ggplot2::geom_smooth(method = loess, colour = "#0000ff44", alpha = 0.2) +
  ggplot2::labs(y = ggplot2::element_blank()) +
  ggplot2::theme_bw()
a4 <- shapviz::sv_dependence(d1, "mp_threshold", color_var = "auto") +
  ggplot2::geom_smooth(method = loess, colour = "#0000ff44", alpha = 0.2) +
  ggplot2::labs(y = ggplot2::element_blank()) +
  ggplot2::theme_bw()
a5 <- shapviz::sv_dependence(d1, "time_constraint", color_var = "auto") +
  ggplot2::geom_smooth(method = loess, colour = "#0000ff44", alpha = 0.2) +
  ggplot2::labs(y = ggplot2::element_blank()) +
  ggplot2::theme_bw()

all2 <- ((a1 + a5 + a3 + a4 +
  plot_layout(guides = "collect")) +
  (a2 + plot_layout(guides = "collect")))
all2 + plot_layout(design = layout) + plot_annotation(
  title = "Shapley value vs. variable values",
  theme = ggplot2::theme_bw()
)
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "Violin plot showing the distribution of the FLOSS score achieved by all tested models by
#|  recording.  The left half shows the recordings that were difficult to predict (10% overall), whereas
#|  the right half shows the recordings that at least one model could achieve a good prediction (10%
#|  overall).  The recordings are sorted (left-right) by the minimum (best) score achieved in descending
#|  order, and ties are sorted by the median of all recording scores.  The blue color highlights
#|  recordings where models had an IQR variability of less than one.  As a simple example, a recording
#|  with just one regime change, and the model predicts exactly one change, far from the truth, the
#|  score will be roughly 1."

all_scores <- readRDS(here::here("output/regime_outputs_lmk.rds"))

scores_stats <- all_scores %>%
  dplyr::select(record, score) %>%
  dplyr::group_by(record) %>%
  dplyr::reframe(
    score = score, min = min(score), q25 = quantile(score, 0.25),
    median = quantile(score, 0.5), q75 = quantile(score, 0.75),
    mean = mean(score), max = max(score)
  )

records_factors <- forcats::as_factor(scores_stats$record)

scores_stats$id <- sprintf("%03d", (as.numeric(records_factors)))

scores_stats %>%
  dplyr::mutate(low_iqr = q75 - q25 < 1) %>%
  dplyr::filter(min > quantile(min, 0.9) | min < quantile(min, 0.1)) %>%
  ggplot2::ggplot(aes(x = reorder(reorder(id, -median), -min), y = score, colour = low_iqr)) +
  ggplot2::geom_violin() +
  ggplot2::coord_cartesian(ylim = c(0, 5)) +
  ggplot2::theme_bw() +
  ggplot2::labs(title = "Scores by recording", colour = "IQR < 1", x = "Recording ID", y = "Score distribution")
#
#
#
#
#
#| fig-cap: "Prediction of the worst 10% of recordings (red is the truth, blue are the predictions)."

worst <- scores_stats %>%
  dplyr::filter(min > quantile(min, 0.9)) %>%
  dplyr::group_by(record) %>%
  dplyr::slice_head() %>%
  dplyr::ungroup() %>%
  dplyr::arrange(desc(min), desc(median)) %>%
  dplyr::slice_head(n = 10) %>%
  dplyr::pull(record)
# "data_25_1.par"  "data_32_12.par" "data_85_1.par"  "data_90_1.par"  "data_68_2.par"

worst_data <- all_scores %>%
  dplyr::filter(record %in% worst) %>%
  dplyr::group_by(record) %>%
  dplyr::slice_min(n = 1, order_by = score, with_ties = FALSE) %>%
  dplyr::arrange(desc(score)) %>%
  dplyr::ungroup()

plots <- list()
for (i in seq_len(nrow(worst_data))) {
  plots[[i]] <- tkplot(worst_data[i, ], FALSE, 50)
}

wrap_plots(plots, ncol = 1)
#
#
#
#
#
#| fig-cap: "Prediction of the best 10% of recordings (red is the truth, blue are the predictions)."

bests <- scores_stats %>%
  dplyr::filter(min < quantile(min, 0.1)) %>%
  dplyr::group_by(record) %>%
  dplyr::slice_head() %>%
  dplyr::ungroup() %>%
  dplyr::arrange(desc(min), desc(median)) %>%
  dplyr::slice_head(n = 10) %>%
  dplyr::pull(record)

bests_data <- all_scores %>%
  dplyr::filter(record %in% bests) %>%
  dplyr::group_by(record) %>%
  dplyr::slice_min(n = 1, order_by = score, with_ties = FALSE) %>%
  dplyr::arrange(desc(score)) %>%
  dplyr::ungroup()

plots <- list()
for (i in seq_len(nrow(bests_data))) {
  plots[[i]] <- tkplot(bests_data[i, ], FALSE, 50)
}

wrap_plots(plots, ncol = 1)
#
#
#
#
#
#
#
#| fig-cap: "Violin plot showing the distribution of the FLOSS score achieved by all tested models during the
#|  inner ressample.  The left half shows the models with the worst performances (10% overall), whereas
#|  the right half shows the models with the best performances (10% overall).
#|  The models are sorted (left-right) by the mean score (top) and by the median (below). Ties are
#|  sorted by the SD and IQR, respectively.  The bluish colors highlights models with an SD below 3
#|  and IQR below 1."

# cores_stats_model <- all_scores %>% dplyr::mutate(across(all_of(predictors_names), as.factor, .unpack = FALSE))

if (file.exists(here("output", "scores_stats_model_rep.rds"))) {
  scores_stats_model <- readRDS(here("output", "scores_stats_model_rep.rds"))
} else {
  scores_stats_model <- all_scores %>%
    dplyr::group_by(across(all_of(predictors_names))) %>%
    dplyr::mutate(model = glue("{window_size}_{time_constraint}_{mp_threshold}_{regime_threshold}_{regime_landmark}")) %>%
    dplyr::reframe(
      record = record,
      model = model,
      score = score, min = min(score), q25 = quantile(score, 0.25),
      median = quantile(score, 0.5), q75 = quantile(score, 0.75),
      iqr = q75 - q25,
      mean = mean(score), max = max(score),
      sd = sd(score)
    )
  saveRDS(scores_stats_model, file = here("output", "scores_stats_model_rep.rds"))
}


scores_stats_model$id <- (sprintf("%05d", (as.numeric(as.factor(scores_stats_model$model)))))
scores_stats_model$id_text <- (sprintf("Model_%05d", (as.numeric(as.factor(scores_stats_model$model)))))
scores_stats_model$record <- (sprintf("%03d", (as.numeric(factor(scores_stats_model$record, labels = levels(records_factors))))))
scores_stats_model <- scores_stats_model %>% dplyr::select(-model)

low <- head(sort(unique(scores_stats_model$mean)), 20)
high <- tail(sort(unique(scores_stats_model$mean)), 20)

model_mean <- scores_stats_model %>%
  dplyr::mutate(low_sd = sd < 3) %>%
  dplyr::filter(mean > high | mean < low) %>%
  ggplot2::ggplot(aes(x = reorder(reorder(id, -sd), -mean), y = score, colour = low_sd)) +
  ggplot2::scale_colour_manual(values = c("FALSE" = "#ff0000c2", "TRUE" = "#0000ffb5")) +
  ggplot2::geom_violin() +
  ggplot2::coord_cartesian(ylim = c(0, 3)) +
  ggplot2::theme_bw() +
  ggplot2::theme(axis.text.x = element_text(size = 8, angle = 90, vjust = 0.5, hjust = 1)) +
  ggplot2::labs(subtitle = "Ordered by Mean and SD", colour = "SD < 3", x = ggplot2::element_blank(), y = "Score distribution")

low <- head(sort(unique(scores_stats_model$median)), 20)
high <- tail(sort(unique(scores_stats_model$median)), 20)

model_median <- scores_stats_model %>%
  dplyr::mutate(low_iqr = q75 - q25 < 1) %>%
  dplyr::filter(median > high | median < low) %>%
  ggplot2::ggplot(aes(x = reorder(reorder(id, -iqr), -median), y = score, colour = low_iqr)) +
  ggplot2::geom_violin() +
  ggplot2::coord_cartesian(ylim = c(0, 3)) +
  ggplot2::theme_bw() +
  ggplot2::theme(axis.text.x = element_text(size = 8, angle = 90, vjust = 0.5, hjust = 1)) +
  ggplot2::labs(subtitle = "Ordered by Median and IQR", colour = "IQR < 1", x = "Model ID", y = "Score distribution")

(model_mean / model_median) + plot_layout(guides = "auto") +
  plot_annotation(
    title = "Scores grouped by model",
    theme = ggplot2::theme_bw()
  )
#
#
#
#
#
#| fig-cap: "Performances of the best 6 models across all inner resample of recordings.
#|  The recordings are ordered by score, from the worst to the best.
#|  Each plot shows one model, starting from the best one.
#|  The red line indicates the median score of the model.
#|  The gray line limits the zero-score region. The plot is limited on the \"y\" axis, and the scores above this
#|  limit are shown in color."

best_models <- scores_stats_model %>%
  dplyr::filter(mean < quantile(mean, 0.1)) %>%
  dplyr::arrange(mean, sd) %>%
  dplyr::pull(id_text) %>%
  unique() %>%
  .[1:6]

plots <- list()
for (i in seq_len(length(best_models))) {
  dd <- scores_stats_model %>% dplyr::filter(id_text == best_models[i])
  plots[[i]] <- ggplot2::ggplot(dd, aes(x = reorder(record, -score), y = score, colour = score)) +
    ggplot2::geom_point(size = 2) +
    ggplot2::geom_hline(aes(yintercept = median), colour = "red") +
    ggplot2::geom_hline(aes(yintercept = mean), colour = "blue") +
    ggplot2::geom_hline(aes(yintercept = 0), colour = "gray50") +
    ggplot2::scale_y_continuous(
      limits = c(0, 3),
      oob = scales::oob_squish,
      expand = c(0.1, 0.05, 0.1, -0.1)
    ) +
    ggplot2::scale_color_gradientn(colors = c("#ffd500db", "#ff8800", "#ff5e00", "#ff0000"), limits = c(3.1, 100)) +
    ggplot2::theme_bw(base_size = 15) +
    ggplot2::theme(axis.text.x = element_text(size = 9, angle = 90, vjust = 0.5, hjust = 1)) +
    ggplot2::labs(
      title = best_models[i],
      colour = "Score out\nof bounds",
      x = ifelse(i == length(best_models), "Record ID", ""),
      y = ggplot2::element_blank()
    )
}

wrap_plots(plots, ncol = 1, guides = "collect") + plot_annotation(
  title = "Performances of the 6 best models",
  theme = ggplot2::theme_bw()
)

#
#
#
#
#
#
#
#
#
#
#| label: tbl-bestparam
#| tbl-cap: "Summary of the five best models. The `mean` shows the inner resample average score. The `holdout` shows
#|  the final score of the model on the holdout set (outer resample)."

if (file.exists(here("output", "regime_outputs_holdout.rds"))) {
  regime_outputs_holdout <- readRDS(here("output", "regime_outputs_holdout.rds"))

  best_parameters <- regime_outputs_holdout$combined %>%
    dplyr::group_by(
      window_size, regime_threshold, regime_landmark, .metric, .estimator
    ) %>%
    dplyr::summarise(mean = mean(.estimate), std_err = sd(.estimate), n = dplyr::n()) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(mean, std_err) %>%
    dplyr::slice_min(n = 5, order_by = mean) %>%
    dplyr::select(-.metric, -.estimator, -n)

  holdout <- regime_outputs_holdout$results %>%
    dplyr::select(.estimate) %>%
    dplyr::rename(holdout = .estimate)

  best_parameters <- dplyr::bind_cols(best_parameters, holdout)

  kable(best_parameters,
    booktabs = TRUE,
    longtable = TRUE,
    align = "cccccc",
    digits = 2,
    position = "ht",
    linesep = ""
  ) %>%
    row_spec(0, bold = TRUE) %>%
    column_spec(6, bold = TRUE)
}
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
network <- readRDS(here::here("output", "classification_network.rds"))
net <- visNetwork::visPhysics(network, hierarchicalRepulsion = list(
  springLength = 1,
  avoidOverlap = 0.5,
  nodeDistance = 120
))
#
#
#
if (knitr::is_latex_output()) {
  my_graphics("theclass-network")
} else {
  visNetwork::visInteraction(net, hover = TRUE, multiselect = TRUE, tooltipDelay = 100)
}
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#| fig-cap: "Set of shapelets for the classification task. Above shows the model number, the coverage (the proportion of true alarms that were detected) and redundancy during the analysis_split (inner resample),
#|  The Precision, the Specificity, and the Km during the testing_split (outer resample)."

data <- readRDS(here("output", "classification_holdout.rds"))

data$plots[[4]] # + ggplot2::facet_wrap(~name, ncol = 1, scales = "free_y")

#
#
#
#
#
#
#
#
#
#
#| tbl-cap: "Performance of the best five sets of shapelet on the inner resample."

colnames <- c("tp", "fp", "tn", "fn", "precision", "recall", "specificity", "accuracy", "f1", "mcc", "km", "kappa")

kable(data$model %>% dplyr::select(dplyr::all_of(colnames)),
  booktabs = TRUE,
  longtable = TRUE,
  # align = "cccccccccc",
  digits = 2,
  position = "ht",
  linesep = ""
) %>%
  row_spec(0, bold = TRUE)

#
#
#
#| tbl-cap: "Performance of the best five sets of shapelet on outer resample."

kable(data$metric %>% dplyr::select(dplyr::all_of(colnames)),
  booktabs = TRUE,
  longtable = TRUE,
  # align = "cccccccccc",
  digits = 2,
  position = "ht",
  linesep = ""
) %>%
  row_spec(0, bold = TRUE)

#
#
#
#| tbl-cap: "The aggregated performance of the best five sets of shapelet on the outer resample. Median, Q25 and Q75"

colnames <- c("precision", "recall", "specificity", "accuracy", "f1_micro", "f1_macro", "mcc", "km", "kappa")

kable(data$overall %>% dplyr::select(dplyr::all_of(colnames)),
  booktabs = TRUE,
  longtable = TRUE,
  # align = "cccccccccc",
  digits = 2,
  position = "ht",
  linesep = "",
) %>%
  row_spec(0, bold = TRUE)

#
#
#
#
#
#
#
#
#
#| fig-cap: "ESP32 MCU"
#|
my_graphics("esp32")
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
source(here("scripts", "common", "compute_floss.R"))

get_dist <- function(mp_const = 1250, floss_const = 0) {
  set.seed(2021)
  iac <- list()
  pro_size <- 5000
  mp_time_constraint <- mp_const
  floss_time_constraint <- floss_const
  for (i in 1:100) {
    iac[[i]] <- get_asym(pro_size, mp_time_constraint, floss_time_constraint)
  }

  aic_avg <- rowMeans(as.data.frame(iac))

  data.frame(index = 1:5000, counts = aic_avg)
}

data_5000 <- get_dist(5000)
data_4250 <- get_dist(4250)
data_2500 <- get_dist(2500)
data_1250 <- get_dist(1250)

floss_data_5000 <- get_dist(0, 5000)
floss_data_4250 <- get_dist(0, 4250)
floss_data_2500 <- get_dist(0, 2500)
floss_data_1250 <- get_dist(0, 1250)
#
#
#
#| fig-cap: "1D-IAC distributions for earlier temporal constraint (on Matrix Profile)"

floss_dist <- ggplot(data_5000, aes(index, counts)) +
  geom_line(size = 0.1) +
  ggtitle("a) No constraint") +
  theme_grey(base_size = 7)

floss_4250 <- ggplot(data_4250, aes(index, counts)) +
  geom_line(size = 0.1) +
  ggtitle("b) Constraint of 4250") +
  theme_grey(base_size = 7)

floss_2500 <- ggplot(data_2500, aes(index, counts)) +
  geom_line(size = 0.1) +
  annotate("segment", y = 0, yend = max(data_2500$counts), x = 2500, xend = 2500, linetype = 2, size = 0.1) +
  annotate("text", x = 2500 - 80, y = 40, label = "start", color = "black", size = 2, angle = 90, hjust = 0) +
  annotate("segment", y = 0, yend = max(data_2500$counts), x = 5000 - 2500 * 0.9, xend = 5000 - 2500 * 0.9, linetype = 2, size = 0.1) +
  annotate("text", x = 5000 - 2500 * 0.9 - 80, y = 40, label = "end", color = "black", size = 2, angle = 90, hjust = 0) +
  ggtitle("c) Constraint of 2500") +
  theme_grey(base_size = 7)

floss_1250 <- ggplot(data_1250, aes(index, counts)) +
  geom_line(size = 0.1) +
  annotate("segment", y = 0, yend = max(data_1250$counts), x = 1250, xend = 1250, linetype = 2, size = 0.1) +
  annotate("text", x = 1250 - 80, y = 40, label = "start", color = "black", size = 2, angle = 90, hjust = 0) +
  annotate("segment", y = 0, yend = max(data_1250$counts), x = 5000 - 1250 * 0.9, xend = 5000 - 1250 * 0.9, linetype = 2, size = 0.1) +
  annotate("text", x = 5000 - 1250 * 0.9 - 80, y = 40, label = "end", color = "black", size = 2, angle = 90, hjust = 0) +
  ggtitle("d) Constraint of 1250") +
  theme_grey(base_size = 7)

gg <- gridExtra::arrangeGrob(floss_dist, floss_4250, floss_2500, floss_1250,
  nrow = 2,
  bottom = grid::textGrob(paste("The plot a) shows the distribution used for the arc count correction when there is no time constraint.", "\n", "b) Shows a constraint of 3/4 of the total. c) 1/2 of the total. d) 1/4 of the total; here we see clearly the flat line.", "\n", "The dashed line marks the start and the end of the uniform zone."), just = "center", gp = grid::gpar(fontsize = 7))
)

grid::grid.draw(gg)
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
